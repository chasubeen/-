### **1-1. 자료구조와 알고리즘**
**자료구조란?** 
- 컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조  ex> 배열: 요소를 각각 선언 시 메모리 구조를 예측하기 hard / 배열을 이용하여 선언 시 메모리 구조를 예측하기 쉽다.
ex> 스택, 큐, 리스트, 사전, 그래프, 트리 등
- 컴퓨터 프로그램 = 자료구조(프로그램에서 사용하는 자료들을 처리하는 용도에 맞게 저장) + 알고리즘(주어진 문제를 처리하는 절차)

*예시> 최고 성적을 구하는 프로그램
``` C
#define MAX_ELEMENTS 100
int scores[MAX_ELEMENTS]; // 자료구조

int get_max_score(int n)  // 학생의 숫자 n을 인수로
{
	int i, largest;
	largest = scores[0];  // 알고리즘
	for (i = 0; i < n; i++)
	{
		if (scores[i] > largest)
		{
			largest = scores[i];
		}
	}
	return largest;
}
```

**알고리즘이란?** 
- 컴퓨터로 문제를 해결하기 위해서 할 일 
  1) 문제를 해결할 수 있는 방법을 고안  
  2) 이들 방법에 따라 컴퓨터가 수행하여야 할 단계적인 절차를 자세히 기술  
  => 컴퓨터로 문제를 풀기 위한 단계적인 절차를 알고리즘(Algorithm)이라고 함 -> 프로그램의 효율성 증가  
  
* 알고리즘이 되기 위한 조건들  
-입력 : 0개 이상의 입력이 존재  
-출력 : 1개 이상의 출력이 존재  
-명백성 : 각 명령어의 의미는 모호하지 않고 명확해야 함.  
-유한성 : 한정된 수의 단계 후에는 반드시 종료되어야 함.  
-유효성 : 각 컴퓨터 명령어들은 실행 가능한 연산이어야 함.  

* 알고리즘 기술 방법  
-자연어 : 장점) 인간이 읽기가 쉬움 / 단점) 단어들을 정확하게 정의하지 않으면 의미 전달이 모호해짐  
-흐름도(flow chart) : 장점) 직관적이고 이해하기 쉬움 / 단점) 복잡한 알고리즘 경우 기술하기 힘듦  
-의사코드(pseudo code): 알고리즘 기술에 가장 많이 사용됨, 자연어보다 더 구조적인 표현 방법, 알고리즘의 핵심 내용에만 집중할 수 있음, 프로그래밍 언어보다는 덜 구체적인 표현 방법
-프로그래밍 언어 : 장점) 가장 정확한 기술이 가능 / 단점) 많은 구체적인 사항들이 알고리즘 내용 이해에 방해될 수 있음

### **1-2. 추상 자료형**
**자료형(Data Type)이란?**
- 데이터의 종류와 이 데이터 간에 가능한 연산들의 집합
* 자료형 종류
-기초 자료형 : int / double / char / float 
-파생 자료형(-> 자료구조) : 배열 / 포인터
-사용자 정의 자료형 : 구조체 / 공용체 / 열거형

**추상 자료형(ADT : Abstract Data Type)이란?**
- 추상적, 수학적으로 자료형을 정의하는 것
- 데이터나 연산이 '무엇(what)인가는 정의되지만 데이터나 연산을 어떻게(how) 컴퓨터 상에서 구현할 것인지는 정의되지 x
ex> 구조체, 클래스 등
- 추상화: 사용자에게 중요한 정보는 강조되고, 반면 중요하지 않은 구현 세부 사항은 제거하는 것

### **1-3. 알고리즘의 성능 분석**
**알고리즘의 성능 분석 기법**
i) 수행 시간 측정 ... 시간적 측면
- 두개의 알고리즘의 실제 수행 시간을 측정하는 것
- 실제 구현 필요
- 동일한 하드웨어를 사용하여야 함

ii) 알고리즘 복잡도 분석 ... 공간적 측면
- 직접 구현하지 않고서도 수행 시간을 분석하는 것
- 알고리즘이 수행하는 연산의 횟수를 측정하여 비교
- 일반적으로 연산의 횟수는 n(=데이터 개수)의 함수

**수행시간 측정**
- 가장 단순한 방법으로 알고리즘을 프로그래밍 언어로 작성해서 실행시킨 다음, 그 수행시간을 측정
- 방법>
  1. clock() 이용
      ``` C
      #include <time.h>
      start = clock();
      ...
      stop = clock();
      double duration = (double)(stop-start) / CLOCKS_PER_SEC;
      ```
  2. time() 이용
     ``` C
     #include <time.h>
     
     start = time(NULL);
     ...
     stop = time(NULL);
     double duration = (double)difftime(stop, start);
     ```
     
  - 문제점>  
    i) 알고리즘을 실제로 구현하고 테스트하는 것이 필요  
    ii) 동일한 하드웨어를 사용해야 함  
    iii) 사용한 소프트웨어 환경에도 영향을 받음  
    
**알고리즘 복잡도 분석(Complexity Analysis)?**
- 알고르짐을 이루고 있는 연산들이 몇 번이나 수행되는지를 숫자로 표시한 
- 직접 구현하지 않고서도 대략적으로 알고리즘의 효율성을 비교할 수 있는 것

**공간복잡도(Space Complexity)**
- 알고리즘이 사용하는 기억공간 분석 
- 알고리즘을 수행 시 필요로 하는 메모리 공간을 분석해서 비교하는 것

**시간복잡도(Time Complexity)**
- 알고리즘의 수행시간 분석
- 알고리즘의 절대적인 수행 시간을 나타내는 것이 아니라, 알고리즘의 연산들이 몇 번이나 수행되었는지를 숫자로 표기
- 연산들의 수행 횟수는 보통 상수라기보다는 프로그램에 주어지는 입력의 개수 n에 따라 변하게 됨
  => 일반적으로 연산의 수행 횟수는 고정된 숫자가 아니라 n에 대한 함수가 됨
- 연산의 수를 입력의 개수 n의 함수로 나타낸 것, T(n)이라고 표기

**빅오표기법?**
- 알고리즘 분석을 쉽게 할 목적으로 불필요한 정보를 제거하여 시간 복잡도를 표시하는 방법 => 연산 횟수의 대략적(점근적) 표현
- 시간 복잡도 함수에서 대입연산, 사칙연산, 비교연산 등을 횟수를 세지만, 정확한 연산의 개수보다는 일반적인 증가 추세가 중요 -> 차수가 가장 큰 항만 고려
- O(n)으로 표기
- n의 값에 따른 함수의 상한 값을 나타내는 방법이다.

* 빅오표기법의 수학적 정의 
=> 두개의 함수 f(n)과 g(n)이 주어졌을 때, 모든 n ≥ n0에 대하여 |f(n)| ≤ c|g(n)|을 만족하는 2개의 상수 c와 n0가 존재하면 f(n)=O(g(n))이다.

* 빅오 표기법 종류
-O(1) : 상수형
- O(log n) : 로그형
- O(n) : 선형
- O(nlogn) : 선형로그형
- O(n^2) : 2차형
- O(n^3) : 3차형
- O(2^n) : 지수형
- O(n!) : 팩토리얼형
**O(1) < O(log n) < O(n) < O(n logn) < O(n^2) < O(n^3) < O(2^n) < O(n!)**

* 예시  
-f(n) = 5 이면 O(1)이다.  
-f(n) = 3n^2 + 100 이면 O(n^2)이다.







