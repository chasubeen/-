# **[7장] 링크드 리스트II**
**⭐ 키워드: 이중 연결 리스트, 음악 재생 프로그램**

## **1. 이중 연결 리스트**
- 응용 프로그램에서 특정 노드의 양방향으로 자유롭게 움직일 필요가 있다면 단순 연결 리스트나 원형 연결 리스트는 부적합  
	-> 이중 연결 리스트를 고안
- 하나의 노드가 선행 노드와 후속 노드에 대한 두 개의 링크를 가지는 리스트
- 장점: 양방향으로 검색이 가능
- 단점: 많은 공간을 차지하고 코드가 복잡해짐

<img src="https://user-images.githubusercontent.com/98953721/200169252-ea3222f0-87e2-4d09-a494-298142ee37cd.png" width = "300" height = "100"/>  
- p = p->llink -> rlink = p->rlink->llink  
  
  => 앞뒤로 똑같이 이동할 수 있음  

### **1-1. 헤드 노드(Head Node)**
- 데이터를 가지고 있지 않은 특별한 노드  
	-> 단지 삽입, 삭제 코드를 간단하게 할 목적으로 만들어진 노드  
- 공백 상태에서는 헤드 노드만 존재  

### **1-2. 노드의 구조**
```C
typedef int element;

typedef struct DlistNode {	// 이중 연결 노드 타입
	element data;             // 데이터 필드
	struct DlistNode *llink;  // 왼쪽 링크 필드 => 선행 노드
	struct DlistNode *rlink;  // 오른쪽 링크 필드 => 후속 노드 
} DlistNode;
```

### **1-3. 삽입 연산**
- 새로 만들어진 노드의 링크는 아무런 정보도 가지고 있지 x  
	-> 새로 만들어진 노드의 링크를 먼저 바꾼다.  
<img src="https://user-images.githubusercontent.com/98953721/200170104-b1383b00-d49b-49e2-9272-7a5a79b0c807.png" width = "450" height = "200"/>  
  
```C
// 새로운 데이터를 선행 노드의 오른쪽에 삽입

void dinsert(DListNode *before, element data){
	DListNode *newnode = (DListNode *)malloc(sizeof(DListNode));
	/*데이터 저장*/
	strcpy(newnode->data, data); // 문자형 데이터라 strcpy() 사용함
	/*링크 생성*/
	newnode->llink = before; // 새로 만들어진 노드의 링크부터 생성
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode; // 후행 노드와 연결
	before->rlink = newnode; // 선행 노드와 연결
}
```

### **1-4. 삭제 연산**
<img src="https://user-images.githubusercontent.com/98953721/200170377-3c7046fb-9cde-4e5f-bec2-5edadcd1de0d.png" width = "450" height = "200"/>  

```C
// 노드 removed를 삭제
void ddelete(DListNode* head, DListNode* removed){
	if (removed == head) return;
	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}
```

### **1-5. 테스트 프로그램**
- 이중 연결 리스트에서는 보통 헤드 노드가 존재함 -> 헤드 포인터 필요 x
- head는 포인터 변수가 아닌 구조체 변수
- 이중 연결 리스트는 사용하기 전에 반드시 초기화를 해야 함  
	-> 헤더 노드의 링크 필드들이 자기 자신을 가리키도록

```C
#include <stdio.h>
#include <stdlib.h>

typedef int element;
typedef struct DListNode { 	// 이중 연결 노드 타입
	element data;
	struct DListNode* llink;
	struct DListNode* rlink;
} DListNode;

/*이중 연결 리스트를 초기화*/
void init(DListNode* phead){
	phead->llink = phead;
	phead->rlink = phead;
}

/*이중 연결 리스트의 노드를 출력*/
void print_dlist(DListNode* phead){
	DListNode* p;
	for (p = phead->rlink; p != phead; p = p->rlink) {
		printf("<-| |%d| |-> ", p->data);
	}
	printf("\n");
}

/*삽입 함수*/
// 새로운 데이터를 노드 before의 오른쪽에 삽입
void dinsert(DListNode* before, element data){
	DListNode* newnode = (DListNode*)malloc(sizeof(DListNode));
	strcpy(newnode->data, data);
	newnode->llink = before;
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode;
	before->rlink = newnode;
}

/*삭제 함수*/
void ddelete(DListNode* head, DListNode* removed){
	if (removed == head) return;
	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}

/*테스트 프로그램*/
int main(void){
	DListNode* head = (DListNode*)malloc(sizeof(DListNode));
	init(head); // 초기화

	printf("추가 단계\n");
	for (int i = 0; i < 5; i++) {
		// 헤드 노드의 오른쪽에 삽입
		dinsert(head, i);
		print_dlist(head);
	}

	printf("\n삭제 단계\n");
	for (int i = 0; i < 5; i++) {
		print_dlist(head);
		ddelete(head, head->rlink);
	}

	free(head);
	return 0;
}
```

# **2. 예제: mp3 재생 프로그램 만들기**

```C
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef char element[100];

/*이중 연결 리스트 구조체 정의*/
typedef struct DlistNode {
	element data;
	struct DlistNode* llink;
	struct DlistNode* rlink;
}DlistNode;

DlistNode* current; // 현재 재생 중인 음악

/*초기화*/
void init(DlistNode* phead) {
	phead->llink = phead;
	phead->rlink = phead;
}

/*출력*/
void print_dlist(DlistNode* phead) {
	DlistNode* p;
	for (p = phead->rlink; p != phead; p = p->rlink) {
		if (p == current)
			printf("<-| #%s# |-> ", p->data);
		else
			printf("<-| %s |-> ", p->data);
	}
	printf("\n");
}

/*삽입*/
void dinsert(DlistNode* before, element data) {
  // 새로운 노드 정의
	DlistNode* newnode = (DlistNode*)malloc(sizeof(DlistNode));
	strcpy(newnode->data, data);
  
	// 링크 생성
	newnode->llink = before;
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode;
	before->rlink = newnode;
}

/*삭제*/
void ddelete(DlistNode* head, DlistNode* removed) {
	if (removed == head) return; // head 노드 삭제 시 링크를 갱신할 필요가 없음

	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}

/*테스트 프로그램*/
int main(void) {
	char ch;
	DlistNode* head = (DlistNode*)malloc(sizeof(DlistNode));
	init(head);

	dinsert(head, "Mamamia");
	dinsert(head, "Dancing Queen");
	dinsert(head, "Fernado");

	current = head->rlink; // 현재 재생중인 음악
	print_dlist(head);

	do {
		printf("\n명령어를 입력하시오(<, >, q): ");
		ch = getchar();
		if (ch == '<') {  // 이전 곡 재생
			current = current->llink;
			if (current == head)
				current = current->llink;
		}
		else if (ch == ">") {  // 다음 곡 
			current = current->rlink;
			if (current == head)
				current = current->rlink;
		}
		print_dlist(head);
		getchar();
	} while (ch != 'q'); // 종료 조건
}
```

### **알고리즘**  
**[dinsert() 원리]**  
<img src = "https://user-images.githubusercontent.com/98953721/206115882-5c49f776-e9c3-4e26-9fde-3740aa2d1468.png" width = 350 height = 150>  

### **실행 결과**
```
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| #Dancing Queen# |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| Dancing Queen |-> <-| #Mamamia# |->

명령어를 입력하시오(<, >, q): >
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): <
<-| Fernando |-> <-| Dancing Queen |-> <-| #Mamamia# |->

명령어를 입력하시오(<, >, q): >
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| #Dancing Queen# |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): <
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): q
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->
```

# **[8장] 트리**
**⭐ 키워드: 순회 방법/ 순환 호출**  

## **1. 트리의 개념**
### **1-1. 선형 자료 구조 vs 계층 자료 구조**
- 선형 자료 구조
  - 자료들이 선형으로 나열되어 있는 구조
  - 리스트, 스택, 큐 등
- 계층 자료 구조
  - 자료들이 계층적 구조로 되어 있음(비선형 구조)
  - 트리 등

### **1-2. 트리**
- 부모-자식 관계의 노드들로 구성
- 응용분야
  - 계층적 조직 표현
  - 컴퓨터 디스크의 디렉토리 구조
  - 결정트리(decision tree)

### **1-3. 트리 용어 정리**
<img src="https://user-images.githubusercontent.com/98953721/200488421-af543b82-1b77-4c46-86a1-44cc99d0ded4.png" width="400" height="200">

- 노드(node): 트리의 구성 요소  
- 루트(root): 최상위 노드, 부모가 없는 노드  
- 서브트리(sub tree): 하나의 노드와 그 노드들의 자손들로 이루어진 트리  
- 간선(edge): 루트와 서브트리를 연결하는 선  
<img src="https://user-images.githubusercontent.com/98953721/200489146-3a48182d-af7f-4ebe-8445-aca0a19164a6.png" width="450" height="250">

- 단말 노드(terminal node, 또는 leaf node): 자식이 없는 노드  
- 비단말 노드: 적어도 하나의 자식을 가지는 노드  

- 레벨(level)  
  - 트리 각 층의 번호  
  - 루트의 레벨은 1, 한 층씩 내려갈수록 1씩 증가  
- 높이(height): 트리의 최대 레벨  
- 차수(degree): 노드가 가지고 있는 자식 노드의 개수  
<img src="https://user-images.githubusercontent.com/98953721/200499461-21fc4671-21bf-4cc5-b3e7-25937b515fc2.png" width="500" height="200">

### **1-4. 트리의 종류**
<img src="https://user-images.githubusercontent.com/98953721/200570785-8c9233c6-caf1-48d3-ac86-9c3debf5a224.png" width="350" height="150">


## **2. 이진 트리 소개**
### **2-1. 이진 트리의 정의**
- 이진 트리(binary tree): 모든 노드가 2개의 서브 트리를 가지고 있는 트리  
  cf> 서브 트리는 공집합일 수 있다.  
	- 이진트리의 노드에는 최대 2개까지의 자식 노드가 존재할 수 있음
  - 모든 노드의 차수는 2 이하
 
**[정의]** 
  - 공집합임  
  - 루트와 왼쪽 서브 트리, 오른쪽 서브 트리로 구성된 노드들의 유한 집합으로 정의됨  
    -> 이진트리의 서브트리들은 모두 이진트리여야 함  
<img src="https://user-images.githubusercontent.com/98953721/200573372-57c80a93-d181-4a1c-ab54-04282e01efbe.png" width="450" height="250">

### **2-2. 이진트리의 성질**
- 노드의 개수가 n개이면 간선의 개수는 (n-1)개
- 높이가 h인 이진트리의 경우 h <= (노드의 개수) <= $2^h -1$
<img src="https://user-images.githubusercontent.com/98953721/200574978-3289aab2-de17-451b-9cb1-d53d3c904ad9.png" width="550" height="250">

- n개의 노드를 가지는 이진트리의 높이: log2 (n+1) <= (높이) <= n

### **2-3. 이진트리의 분류**
- 포화 이진 트리(full binary tree)
  - 트리의 각 레벨에 노드가 꽉 차있는 이진트리
- 완전 이진 트리(complete binary tree)
- 기타 이진 트리  


## **3. 이진 트리의 표현**
### **3-1. 배열 표현법**
- 주로 포화 이진 트리 또는 완전 이진 트리의 경우 많이 활용
- 모든 트리를 **포화 이진 트리**라고 가정
- 각 노드에 번호를 붙여서 그 번호를 배열의 index로 삼아 노드의 데이터를 배열에 저장하는 방법
	- 인덱스 0은 사용하지 X
<img src = "https://user-images.githubusercontent.com/98953721/206753975-31490b07-4ff6-47b4-aede-2ef0993a76b7.png" width = 550 height = 200>

- 부모 index & 자식 index
  - 노드 i의 부모 노드 index: i/2
  - 노드 i의 왼쪽 자식 노드 index: 2 * i
  - 노드 i의 오른쪽 자식 노드 index: 2 * i + 1   

### **3-2. 링크 표현법**
- 트리의 노드를 구조체로 표현
- 각 노드가 포인터를 가지고 있음 -> 해당 포인터를 통해 노드와 노드 연결
<img src = "https://user-images.githubusercontent.com/98953721/206755797-a85b8647-aafc-4e6e-a6d8-7b2dfd7a741b.png" width = 550 height = 400>

- 루트 노드를 가리키는 포인터만 있으면 트리 안의 모든 노드들에 접근 가능

```C
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

// 노드 구조체 정의
typedef struct TreeNode {
	int data;
	struct TreeNode *left, *right;
} TreeNode;


//  		  n1
//		   /  \
//		 n2    n3


int main(void){
	TreeNode *n1, *n2, *n3;
	// 노드 메모리 할당
	n1 = (TreeNode *)malloc(sizeof(TreeNode));
	n2 = (TreeNode *)malloc(sizeof(TreeNode));
	n3 = (TreeNode *)malloc(sizeof(TreeNode));
	
	/*노드 데이터 저장 & 링크 생성*/
	n1->data = 10;		// 첫 번째 노드
	n1->left = n2;
	n1->right = n3;
	
	n2->data = 20;		// 두 번째 노드
	n2->left = NULL;
	n2->right = NULL;
	
	n3->data = 30;		// 세 번째 노드
	n3->left = NULL;
	n3->right = NULL;
	
	free(n1); free(n2); free(n3);
	
	return 0;
}
```

## **⭐ 4. 이진 트리의 순회**
- 순회(traversal): 트리의 노드들을 체계적으로 방문하는 것

### **4-1. 이진 트리 순회 방법**
- 3가지 기본적인 순회 방법
	- 루트(V)와 왼쪽 서브 트리(L), 오른쪽 서브 트리(R) 중 루트를 언제 방문하냐에 따라 구분
- **순환 호출** 이용

1) 전위 순회(preorder traversal) --- VLR  
	- 자손 노드보다 루트 노드를 먼저 방문
	- 활용: 구조화된 문서 출력
	<img src = "https://user-images.githubusercontent.com/98953721/206758327-27310218-3e30-4895-ba83-ecbf2b6c9bef.png" width = 250 height = 130>
	
2) 중위 순회(inorder traversal) --- LVR
	- 왼쪽 자손, 루트, 오른쪽 자손 순으로 방문
	- 예: 수식 트리
	<img src = "https://user-images.githubusercontent.com/98953721/206758675-504e33e5-3d2b-4066-81fc-7b19ea34171a.png" width = 250 height = 130>

3) 후위 순회(postorder traversal) --- LRV
	- 루트 노드보다 자손을 먼저 방문
	- 예: 디렉토리 용량 계산
	<img src = "https://user-images.githubusercontent.com/98953721/206758959-31c1f9c2-1e8c-4d95-8e96-6f912321df5d.png" width = 250 height = 130>
	
```C
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

// 트리 노드 구조체 정의
typedef struct TreeNode {
	int data; // 노드의 값
	struct TreeNode* left, * right; // 링크
} TreeNode;

//			15
//		4		 20
//    1		  16    25

// 노드를 전역 변수로 정의하였음을 유의
// 리프 노드부터 정의
TreeNode n1 = { 1,  NULL, NULL };
TreeNode n2 = { 4,  &n1,  NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3,  &n4 };
TreeNode n6 = { 15, &n2,  &n5 };
TreeNode* root = &n6;

// 중위 순회(LVR)
void inorder(TreeNode* root) {
	if (root != NULL) {
		inorder(root->left);	// 왼쪽 서브 트리 순회
		printf("[%d] ", root->data);  // 노드 방문(출력)
		inorder(root->right);	// 오른쪽 서브 트리 순회
	}
}

// 전위 순회(VLR)
void preorder(TreeNode* root) {
	if (root != NULL) {
		printf("[%d] ", root->data);  // 노드 방문(출력)
		preorder(root->left);// 왼쪽 서브 트리 순회
		preorder(root->right);// 오른쪽 서브 트리 순회
	}
}

// 후위 순회(LRV)
void postorder(TreeNode* root) {
	if (root != NULL) {
		postorder(root->left);	// 왼쪽 서브 트리 순회
		postorder(root->right); // 오른쪽 서브 트리 순회
		printf("[%d] ", root->data); // 노드 방문(출력)
	}
}

int main(void){
	printf("중위 순회=");
	inorder(root);
	printf("\n");

	printf("전위 순회=");
	preorder(root);
	printf("\n");

	printf("후위 순회=");
	postorder(root);
	printf("\n");

	return 0;
}
```

**[결과]**  
```
중위 순회=[1] [4] [15] [16] [20] [25]
전위 순회=[15] [4] [1] [20] [16] [25]
후위 순회=[1] [4] [16] [25] [20] [15]
```

## **5. 반복적 순회**
- 스택에 자식 노드들을 저장하고 꺼내면서 순회

### **5-1. 중위 순회**
```C
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>

/*트리 노드 구조체*/
typedef struct TreeNode {
	int data; // 데이터
	struct TreeNode* left, * right; // 링크
} TreeNode;

#define SIZE 100 // 스택의 크기를 100으로 지정
int top = -1;
TreeNode* stack[SIZE]; // 스택 선언

/*데이터 입력(push)*/
void push(TreeNode* p){
	if (top < SIZE - 1)
		stack[++top] = p;
}

/*데이터 출력(pop)*/
TreeNode* pop(){
	TreeNode* p = NULL;
	if (top >= 0)
		p = stack[top--];
	return p;
}

/*중순위 탐방*/
void inorder_iter(TreeNode* root){
	while (1) {
		for (; root; root = root->left)
			push(root); 
		root = pop();
		if (!root) break;

		printf("[%d] ", root->data);
		root = root->right;
	}
}


//          15
//      4	      20
//    1	      16  25

// 노드 정의
TreeNode n1 = { 1,  NULL, NULL };
TreeNode n2 = { 4,  &n1,  NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3,  &n4 };
TreeNode n6 = { 15, &n2,  &n5 };
TreeNode* root = &n6;

int main(void){
	printf("중위 순회=");
	inorder_iter(root);
	printf("\n");
	return 0;
}
 ```
 
 **[Simulation]**  
 <img src="https://user-images.githubusercontent.com/98953721/200721388-ca79d3a0-7618-4662-9ffd-3f36ffae352d.png" width="650" height="400">

**[실행 결과]**
```
중위 순회 = [1] [4] [15] [16] [20] [25]
```

## **6. 이진 탐색 트리(Binary Search Tree)**
- 이진 트리 기반의 탐색을 위한 자료 구조
- 탐색 작업을 효유적으로 하기 위한 자료구조
- **[정의]**  
	- 모든 원소의 키는 유일하다.
	- key(왼쪽 서브트리) <= key(루트 노드) <= key(오른쪽 서브트리)
	- 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리임
- 중위순회 -> 값의 오름차순 정렬
<img src="https://user-images.githubusercontent.com/98953721/200828293-ce7c37c8-6953-4336-b73e-a9f4ce48adca.png" width="250" height="300">
<img src="https://user-images.githubusercontent.com/98953721/200829569-ba8b9456-f018-4b02-9066-e55833799edf.png" width="600" height="400">

### **⭐ 6-1. 순환적 탐색**
- 정렬 -> 탐색
- 비교 결과에 따라 3가지로 나누어짐
	- 주어진 키 == 루트 노드의 키: 탐색 성공
	- 주어진 키 < 루트 노드의 키: 루트 노드의 **왼쪽** 노드 기준으로 다시 탐색 시작
	- 주어진 키 > 루트 노드의 키: 루트 노드의 **오른쪽** 노드 기준으로 다시 탐색 시작

```C
/*순환적 탐색 함수*/
TreeNode* search(TreeNode* node, int key) {
	if (node == NULL) return NULL;
	if (key == node->key) return node; 
	else if (key < node->key)
		return search(node->left, key);
	else
		return search(node->right, key);
}
```
### **6-2. 반복적 탐색**

```C
/*반복적 탐색 함수*/
TreeNode* search(TreeNode* node, int key) {
	while (node != NULL) {
		if (key == node->key) return node;
		else if (key < node->key)
			node = node->left;
		else
			node = node->right;
	}
	return NULL; // 탐색 실패 시 NULL 반환
}
```

### **6-3. 삽입 연산**
- 이진 탐색 트리에서는 같은 키 값을 갖는 노드가 없어야 함
- 탐색 수행 -> 탐색에 실패한 위치가 바로 새로운 노드를 삽입하는 위치
- 새로운 노드는 항상 단말 노드(리프노드)에 추가됨  
  -> 새로운 노드가 단말 노드의 하위 노드로 추가됨  
<img src="https://user-images.githubusercontent.com/98953721/201104111-b8f5e8b4-b9b9-4ded-abfc-86bca14fbe0e.png" width="600" height="300">

```C
TreeNode* new_node(int item) {
	TreeNode* temp = (TreeNode*)malloc(sizeof(TreeNode));
	temp->key = item;
	temp->left = temp->right = NULL;
	return temp;
}

TreeNode* insert_node(TreeNode* node, int key) {
	// 트리가 공백이면 새로운 노드를 반환
	if (node == NULL) return new_node(key);
	// 그렇지 않으면 순환적으로 트리 내려가기
	if (key < node->key)
		node->left = insert_node(node->left, key);
	else if (key > node->key)
		node->right = insert_node(node->right, key);

	// 변경된 루트 포인터 반환
	return node;
}
```

### **6-4. 삭제 연산**
**[3가지 경우]**
1) 삭제하려는 노드가 단말 노드인 경우
2) 삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브 트리 중 하나만 가지고 있는 경우
3) 삭제하려는 노드가 두 개의 서브 트리를 모두 가지고 있는 경우

**[Case 1]**
- 단말 노드만 삭제
- 단말 노드의 부모 노드를 찾아서 부모 노드 안의 링크 필드를 NULL로 만들어서 연결 끊기
<img src="https://user-images.githubusercontent.com/98953721/201107511-6c479f6c-2168-4b58-afde-e8748ddba69a.png" width="650" height="300">

**[Case 2]**
- 자기 노드는 삭제
- 서브 트리는 자기 노드의 부모 노드에 붙여주기
<img src="https://user-images.githubusercontent.com/98953721/201108047-06f3b765-e13f-45a6-a61a-3af7469c4f8c.png" width="650" height="300">

**[Case 3]**
- 삭제 노드와 가장 비슷한 값을 가진 노드를 삭제 노드의 위치로 가져오기
<img src="https://user-images.githubusercontent.com/98953721/201109063-0fd92302-aa41-445e-b6a3-cf76bb559bf7.png" width="750" height="250">

- p: 부모 노드
- t: 현재 노드
- succ: 후계자 노드
- succ_p: 후계자 노드의 부모

```C
Treenode* min_value_node(TreeNode* node) {
	TreeNode* current = node;

	// 맨 왼쪽 단말 노드를 찾으러 내려감
	while (current->left != NULL)
		current = current->left;

	return current;
}


// 이진 탐색 트리의 키가 주어지면 키가 저장된 노드를 삭제하고
// 새로운 루트 노드를 반환한다.
TreeNode* delete_node(TreeNode* root, int key) {
	// 1. 삭제할 노드 탐색 

	if (root == NULL) return root;
	
	// 만약 키가 루트보다 작으면 왼쪽 서브 트리에 있는 것임
	if (key < root->key)
		root->left = delete_node(root->left, key);
		
	// 만약 키가 루트보다 크면 오른쪽 서브 트리에 있는 것임
	if (key > root->key)
		root->right = delete_node(root->right, key);
	// 키 == 루트 -> 해당 노드 삭제


	// 2.
	else {
		// Case1 or Case2
		if (root->left == NULL) {
			TreeNode* temp = root->right;
			free(root);
			return temp;
		}
		else if (root->right == NULL) {
			TreeNode* temp = root->left;
			free(root);
			return temp;
		}

		// Case 3
		TreeNode* temp = min_value_node(root->right);

		// 중위 순회 시 후속 노드를 복사
		root->key = temp->key;
		// 중위 순회 시 후속 노드 삭제
		root->right = delete_node(root->right, temp->key);
	}
	return root;
}
```

**[전체 프로그램]**
```C
#include <stdio.h>
#include <stdlib.h>

// 노드 정의
typedef int element;
typedef struct TreeNode {
	element key;
	struct TreeNode* left, * right;
} TreeNode;


// 순환적인 탐색 함수
TreeNode* search(TreeNode* node, int key){
	if (node == NULL) return NULL;
	if (key == node->key) return node;
	else if (key < node->key)
		return search(node->left, key);
	else
		return search(node->right, key);
}

// 새로운 노드 생성 함수
TreeNode* new_node(int item){
	TreeNode* temp = (TreeNode*)malloc(sizeof(TreeNode));
	temp->key = item;
	temp->left = temp->right = NULL;
	return temp;
}

// 노드 삽입 함수
TreeNode* insert_node(TreeNode* node, int key){
	// 트리가 공백이면 새로운 노드를 반환한다. 
	if (node == NULL) return new_node(key);

	// 그렇지 않으면 순환적으로 트리를 내려간다. 
	if (key < node->key)
		node->left = insert_node(node->left, key);
	else if (key > node->key)
		node->right = insert_node(node->right, key);

	// 변경된 루트 포인터를 반환한다. 
	return node;
}

// 최솟값을 가지는 노드 탐색
TreeNode* min_value_node(TreeNode* node){
	TreeNode* current = node;

	// 맨 왼쪽 단말 노드를 찾으러 내려감
	while (current->left != NULL)
		current = current->left;

	return current;
}

// 이진 탐색 트리와 키가 주어지면 키가 저장된 노드를 삭제하고 
// 새로운 루트 노드를 반환한다. 
TreeNode* delete_node(TreeNode* root, int key){
	if (root == NULL) return root;

	// 만약 키가 루트보다 작으면 왼쪽 서브 트리에 있는 것임
	if (key < root->key)
		root->left = delete_node(root->left, key);
	// 만약 키가 루트보다 크면 오른쪽 서브 트리에 있는 것임
	else if (key > root->key)
		root->right = delete_node(root->right, key);
	// 키가 루트와 같으면 이 노드를 삭제하면 됨

	else {
		// 첫 번째나 두 번째 경우
		if (root->left == NULL) {
			TreeNode* temp = root->right;
			free(root);
			return temp;
		}
		else if (root->right == NULL) {
			TreeNode* temp = root->left;
			free(root);
			return temp;
		}

		// 세 번째 경우
		TreeNode* temp = min_value_node(root->right);

		// 중외 순회시 후계 노드를 복사한다. 
		root->key = temp->key;
		// 중외 순회시 후계 노드를 삭제한다. 
		root->right = delete_node(root->right, temp->key);
	}
	return root;
}

// 중위 순회
void inorder(TreeNode* root) {
	if (root) {
		inorder(root->left); // 왼쪽 서브트리 순회
		printf("[%d] ", root->key);  // 노드 방문
		inorder(root->right); // 오른쪽 서브트리 순회
	}
}

int main(void){
	TreeNode* root = NULL;
	TreeNode* tmp = NULL;

	root = insert_node(root, 30);
	root = insert_node(root, 20);
	root = insert_node(root, 10);
	root = insert_node(root, 40);
	root = insert_node(root, 50);
	root = insert_node(root, 60);

	printf("이진 탐색 트리 중위 순회 결과 \n");
	inorder(root);
	printf("\n\n");
	if (search(root, 30) != NULL)
		printf("이진 탐색 트리에서 30을 발견함 \n");
	else
		printf("이진 탐색 트리에서 30을 발견못함 \n");
	return 0;
}
```

**[실행 결과]**

```C
이진 탐색 트리 중위 순회 결과
[10] [20] [30] [40] [50] [60]

이진 탐색 트리에서 30을 발견함
```

### **6-5. 이진 탐색 트리의 분석**
- 트리의 높이를 h라고 했을 떄 탐색, 삽입, 삭제 연산의 시간 복잡도는 h에 비례 => O(h)
- 최선의 경우
	- 이진 트리가 균형적으로 생성되어 있는 경우
	- $log{2}{n}$ => O($log{2}{n}$)
<img src="https://user-images.githubusercontent.com/98953721/201114702-f5bf2ca1-9dfb-475c-9d68-460a5b14128e.png" width="650" height="250">

- 최악의 경우
	- 한쪽으로 치우치는 경사 트리
	- h = n
	- 순차적 탐색과 시간 복잡도가 동일


# **[9장] 우선순위 큐**

## **1. 우선순위 큐**
### **1-1. 우선순위 큐의 소게**
- 우선순위 큐(Priority queue): 우선 순위를 가진 항목들을 저장하는 큐
- 우선순위가 높은 데이터가 먼저 나가게 됨
- 스택/큐/우선순위 큐
<img src = "https://user-images.githubusercontent.com/98953721/201929789-b8e3ee5b-2ff6-411b-9939-462d29280d77.png" width = 800 height = 170>

- 응용분야
  - 시뮬레이션 시스템
  - 네트워크 트래픽 제어
  - 운영 체제에서의 작업 스케쥴링
  - 수치 해석적인 계산 등

### **1-2. 우선순위 큐의 종류**
- 최소 우선순위 큐
- 최대 우선순위 큐

## **2. 우선순위 큐의 구현 방법**
### **히프 활용**
- 완전 이진 트리의 일종인 히프 이용
- 느슨한 정렬 상태 -> 효율 측면에서 상당히 유리함
<img src = "https://user-images.githubusercontent.com/98953721/201934681-b358436e-8eed-44b2-9069-335cb3518688.png" width = 900 height = 200>

## **3. 히프(Heap)**
### **3-1. 히프의 개념**
- 노드의 키들이 다음 식을 만족하는 **완전 이진 트리**
  - key(부모 노드) >= key(자식 노드)
- 이진 탐색 트리와 다르게 중복된 값 허용
- 느슨한 정렬 상태  
  =>  큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있는 정도
<img src = "https://user-images.githubusercontent.com/98953721/201936391-c5fbb32d-814e-4f87-8763-dc0032b2750c.png" width = 600 height = 200>

### **3-2. 히프의 종류**
- 최대 히프(max heap)
  - 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
  - key(부모 노드) >= key(자식 노드)
  <img src = "https://user-images.githubusercontent.com/98953721/201937495-c7db9e3f-93ff-4058-a2c7-346576c05645.png" width = 600 height = 300>
  
- 최소 히프(min heap)
  - 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
  - key(부모 노드) <= key(자식 노드)
  <img src = "https://user-images.githubusercontent.com/98953721/201937696-950f5296-0c2b-42ee-8da6-8985518041be.png" width = 600 height = 300>

- 히프의 높이
  - N개의 노드를 가지고 있는 히프의 높이는 **O(logn)**
  - 히프는 **완전 이진 트리**  
    => 마자막 레벨 h를 제외하고는 각 레벨 i에 2^i-1개의 노드 존재 
  
### **3-3. 히프의 구조**
- 각각의 노드에 번호를 붙임 -> 배열의 index로 활용
- 히프를 저장하는 표준적인 자료구조: 배열
  - 구현의 편의성을 위해 index 0번은 사용x
- 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변화x
- 부모 노드와 자식 노드의 탐색이 용이
  - 왼쪽 자식의 index = (부모의 index) * 2
  - 오른쪽 자식의 index = (부모의 index) * 2 + 1 
  - 부모의 index = (자식의 index)/2
<img src = "https://user-images.githubusercontent.com/98953721/201943100-422be0ac-5b8e-4f88-b3a8-70812457ef69.png" width = 600 height = 350>


## **4. 히프 구현**

### **4-1. 히프 정의하기**
```C
#define MAX_ELEMENT 200

// 히프의 각 요소들
typedef struct{
  int key;
}element;
// 1차원 배열 정의 -> heap 구현
typedef struct{
  element heap[MAX_ELEMENT];
  int heap_size; // 현재 히프 안에 저장된 요소의 개수
}HeapType;
```
**[히프의 생성]**  
```C
HeapType heap;
```
```C
HeapType* heap = create(); // 메모리 동적 할당 활용
```

### **4-2. 삽입 연산**
- 최대 히프라 가정
1) 히프에 새로운 요소가 들어오면, 일단 새로운 노드를 히프의 마지막 노드에 이어서 삽입
2) 삽입 후 새로운 노드를 부모 노드들과 교환 -> 히프의 성질 만족
  
**[예시]**  
<img src = "https://user-images.githubusercontent.com/98953721/201945397-ceb1311d-12de-4d8f-9fdf-90a069769da8.png" width = 500 height = 200>  
<img src = "https://user-images.githubusercontent.com/98953721/201945919-3947ef29-5668-49a9-bfdd-e5ecaaa6e19a.png" width = 500 height = 200>  
<img src = "https://user-images.githubusercontent.com/98953721/201946266-b7799218-a72c-40ae-99bb-581b061c4f49.png" width = 500 height = 200>    
4) 삽입 노드 8이 부모 노드 9보다 작으므로 더 이상 교환하지 않는다.  

**[코드]**  
```C
// 현재 요소의 개수가 heap_size인 히프 h에 item을 삽입
// 삽입 함수

void insert_max_heap(HeapType* h, element item) {
	int i;
	i = ++(h->heap_size);

	// 트리를 거슬러 올라가면서 부모 노드와 비교
	// 삽입 위치 탐색 -> 부모 노드만을 끌어내림
	while ((i != 1) && (item.key > h->heap[i / 2].key)) {
		h->heap[i] = h->heap[i / 2];
		i /= 2;
	}
	h->heap[i] = item; // 새로운 노드 삽입
}
```

### **4-3. 삭제 연산**
- 최대 히프라 가정
1) 루트 노드 삭제
2) 마지막 노드를 루트 노드로 이동
3) 루트에서부터 단말 노드까지의 경로에 있는 노드들을 교환하여 히프 성질 만족시키기

**[예시]**    
<img src = "https://user-images.githubusercontent.com/98953721/201948507-c20a931b-d80e-4d06-aa05-98da7f177254.png" width = 500 height = 200>  
<img src = "https://user-images.githubusercontent.com/98953721/201948903-8abb11de-714e-4f46-b9fd-9152dc0ae269.png" width = 500 height = 200>  
<img src = "https://user-images.githubusercontent.com/98953721/201949145-25c2dc5f-8de7-4a8d-9acb-d938da36bf8d.png" width = 500 height = 200>    
4) 3이 자식 노드인 2와 1보다 크기 때문에 더 이상의 교환은 필요없다.

**[코드]**  
```C
// 삭제 함수

element delete_max_heap(HeapType* h) {
	int parent, child;
	element item, temp;

	item = h->heap[1]; // 루트 노드 값의 반환을 위해 item 변수에 일단 저징
	temp = h->heap[(h->heap_size)--]; // 말단 노드를 루트 노드로 -> 히프의 크기를 1 줄이기
	parent = 1; // 일단 부모 노드는 1번 노드
	child = 2; // 일단 자식 노드는 2번 노드
	while (child <= h->heap_size) {
		// 현재 노드의 자식 노드 중 더 큰 자식 노드 찾기
		if((child < h->heap_size) && (h->heap[child].key) < (h->heap[child + 1].key))
			child++;
		if (temp.key >= h->heap[child].key) break;

		// 한 단계 아래로 이동
		h->heap[parent] = h->heap[child];
		parent = child;
		child *= 2;
	}
	h->heap[parent] = temp;
	return item;
}
```

### **4-4. 전체 프로그램**

**[코드]**

```C
#include <stdio.h>
#include <stdlib.h>

#define MAX_ELEMENT 200
typedef struct {
	int key;
} element;
typedef struct {
	element heap[MAX_ELEMENT];
	int heap_size;
} HeapType;


// 생성 함수(메모리 동적 할당)
HeapType* create(){
	return (HeapType*)malloc(sizeof(HeapType)); 
}

// 초기화 함수
void init(HeapType* h){
	h->heap_size = 0;
}

// 삽입 함수
// 현재 요소의 개수가 heap_size인 히프 h에 item을 삽입
void insert_max_heap(HeapType* h, element item){
	int i;
	i = ++(h->heap_size);
	//  트리를 거슬러 올라가면서 부모 노드와 비교
	while ((i != 1) && (item.key > h->heap[i / 2].key)) {
		h->heap[i] = h->heap[i / 2];
		i /= 2;
	}
	h->heap[i] = item; // 새로운 노드를 삽입
}

// 삭제 함수
element delete_max_heap(HeapType* h){
	int parent, child;
	element item, temp;

	item = h->heap[1];
	temp = h->heap[(h->heap_size)--];
	parent = 1;
	child = 2;
	while (child <= h->heap_size) {
		// 현재 노드의 자식노드 중 더 작은 자식노드를 찾기
		if ((child < h->heap_size) &&
			(h->heap[child].key) < h->heap[child + 1].key)
			child++;
		if (temp.key >= h->heap[child].key) break;

		// 한 단계 아래로 이동
		h->heap[parent] = h->heap[child];
		parent = child;
		child *= 2;
	}
	h->heap[parent] = temp;
	return item;
}

int main(void){
	element e1 = {10}, e2 = {5}, e3 = {30};
	element e4, e5, e6;
	HeapType* heap;

	heap = create(); // 히프 생성
	init(heap);	// 초기화
	
  // 삽입
	insert_max_heap(heap, e1);
	insert_max_heap(heap, e2);
	insert_max_heap(heap, e3);

	// 삭제
	e4 = delete_max_heap(heap);
	printf("< %d > ", e4.key);
	e5 = delete_max_heap(heap);
	printf("< %d > ", e5.key);
	e6 = delete_max_heap(heap);
	printf("< %d > \n", e6.key);

	free(heap);
	return 0;
}
```

**[실행 결과]**
```
< 30 > < 10 > < 5 >
```

### **4-5. 복잡도 분석**
- 삽입
	- 최악의 경우 루트 노드까지 올라가야 함
	- 트리의 높이에 해당하는 비교 연산 및 이동 연산 필요  
	=> O(logn)
- 삭제
	- 최악의 경우 가장 아래 레벨까지 내려가야 함
	- 트리의 높이에 해당하는 비교 연산 및 이동 연산 필요  
	=> O(logn)


## **5. 히프 정렬**
- 최대 히프를 이용해 정렬
- 먼저 정렬해야 할 n개의 요소들을 최대 히프에 삽입하고, 한 번에 하나씩 히프에서 요소들을 삭제하여 저장하면 됨
- n개의 요소는 O(nlogn) 시간 내에 정렬됨
	- 하나의 요소를 히프에 삽입/삭제 시 O(logn) 시간 소요
	- 요소의 개수가 n => n번 반복
- 전체 자료의 정렬이 아닌 가장 큰 값 몇 개만을 정렬 시 유리한 알고리즘

### **히프 정렬의 구현**
- 최소 히프라고 가정  

**[코드]**  
```C
#include <stdio.h>
#include <stdlib.h>

#define MAX_ELEMENT 200

typedef struct {
	int key;
} element;
typedef struct {
	element heap[MAX_ELEMENT];
	int heap_size;
} HeapType;


// 생성 함수
HeapType* create(){
	return (HeapType*)malloc(sizeof(HeapType));
}

// 초기화 함수
void init(HeapType* h){
	h->heap_size = 0;
}

// 삽입 함수
// 현재 요소의 개수가 heap_size인 히프 h에 item을 삽입한다.
void insert_max_heap(HeapType* h, element item){
	int i;
	i = ++(h->heap_size);

	// 트리를 거슬러 올라가면서 부모 노드와 비교
	while ((i != 1) && (item.key > h->heap[i / 2].key)) {
		h->heap[i] = h->heap[i / 2];
		i /= 2;
	}
	h->heap[i] = item; // 새로운 노드를 삽입
}

// 삭제 함수
element delete_max_heap(HeapType* h){
	int parent, child;
	element item, temp;

	item = h->heap[1];
	temp = h->heap[(h->heap_size)--];
	parent = 1;
	child = 2;
	while (child <= h->heap_size) {
		// 현재 노드의 자식노드 중 더 작은 자식노드 찾기
		if ((child < h->heap_size) &&
			(h->heap[child].key) < h->heap[child + 1].key)
			child++;
		if (temp.key >= h->heap[child].key) break;
		// 한 단계 아래로 이동
		h->heap[parent] = h->heap[child];
		parent = child;
		child *= 2;
	}
	h->heap[parent] = temp;
	return item;
}

// 정렬
void heap_sort(element a[], int n){
	int i;
	HeapType* h;

	h = create(); // heap 생성(메모리 할당)
	init(h); // 초기화
	// 삽입
	for (i = 0; i < n; i++) {
		insert_max_heap(h, a[i]);
	}
	// 삭제 -> 삭제되는 요소들을 배열에 저장
	// 오름차순 정렬
	for (i = (n - 1); i >= 0; i--) {
		a[i] = delete_max_heap(h);
	}
	free(h);
}


#define SIZE 8

int main(void){
	element list[SIZE] = {23, 56, 11, 9, 56, 99, 27, 34};
	heap_sort(list, SIZE); // 정렬
	for (int i = 0; i < SIZE; i++) {
		printf("%d ", list[i].key);
	}
	printf("\n");
	return 0;
}
```

**[실행 결과]**
```
9 11 23 27 34 56 56 99
```

## **⭐ 6. 머신 스케줄링**
- 한정된 기계를 모두 사용하여 최소 시간 내에 작업들을 모두 끝낼 수 있도록 조정하는 작업
- 최적 해 탐색 방법: **LPT(Longest Processing Time first)**

### **LPT(Longest Processing Time first)**
- 가장 긴 작업을 우선적으로 기계에 할당하는 것
<img src = "https://user-images.githubusercontent.com/98953721/202064181-d3462ec0-2ed3-4074-80a3-03bde54359a9.png" width = 800 height = 100>  
<img src = "https://user-images.githubusercontent.com/98953721/202064193-920de117-898e-45b3-a039-d9f35cb52a43.png" width = 800 height = 150>

- 기계의 **종료 시간**에 주목
	- 기계의 종료 시간을 최소 히프에 넣고 최소 히프에서 기계를 꺼내서 그 기계에 작업 할당
	- 작업 할당 후 기계의 종료 시간을 작업 시간만큼 증가 후 다시 최소 히프에 삽입

**[코드]**
```C
#include <stdio.h>
#define MAX_ELEMENT 200

typedef struct {
	int id;
	int avail;
} element;

typedef struct {
	element heap[MAX_ELEMENT];
	int heap_size;
} HeapType;

// 생성 함수
HeapType* create(){
	return (HeapType*)malloc(sizeof(HeapType));
}

// 초기화 함수
void init(HeapType* h){
	h->heap_size = 0;
}

// 삽입 함수
// 현재 요소의 개수가 heap_size인 최소 히프 h에 item을 삽입
void insert_min_heap(HeapType* h, element item){
	int i;
	i = ++(h->heap_size);

	//  트리를 거슬러 올라가면서 부모 노드와 비교
	while ((i != 1) && (item.avail < h->heap[i / 2].avail)) {
		h->heap[i] = h->heap[i / 2];
		i /= 2;
	}
	h->heap[i] = item; // 새로운 노드를 삽입
}

// 삭제 함수
element delete_min_heap(HeapType* h){
	int parent, child;
	element item, temp;

	item = h->heap[1];
	temp = h->heap[(h->heap_size)--];
	parent = 1;
	child = 2;
	while (child <= h->heap_size) {
		// 현재 노드의 자식노드중 더 작은 자식노드 찾기
		if ((child < h->heap_size) &&
			(h->heap[child].avail) > h->heap[child + 1].avail)
			child++;
		if (temp.avail < h->heap[child].avail) break;

		// 한 단계 아래로 이동
		h->heap[parent] = h->heap[child];
		parent = child;
		child *= 2;
	}
	h->heap[parent] = temp;
	return item;
}

#define JOBS 7 // 작업의 수
#define MACHINES 3 // 기계의 수

int main(void){
	int jobs[JOBS] = { 8, 7, 6, 5, 3, 2, 1 };	// 작업은 정렬되어 있다고 가정
	element m = {0, 0};
	HeapType* h;
	h = create();
	init(h);

	for (int i = 0; i < MACHINES; i++) {
		m.id = i + 1;
		m.avail = 0; // 기계가 사용 가능하게 되는 시간 
		insert_min_heap(h, m);
	}
	// 최소 히프에서 기계를 꺼내서 작업을 할당하고 사용 가능 시간을 증가 후 
	// 다시 최소 히프에 추가
	for (int i = 0; i < JOBS; i++) {
		m = delete_min_heap(h);
		printf("JOB %d을 시간=%d부터 시간=%d까지 기계 %d번에 할당한다. \n",
			i, m.avail, m.avail + jobs[i] - 1, m.id);
		m.avail += jobs[i];
		insert_min_heap(h, m);
	}
	return 0;
}
```

**[실행 결과]**
```
JOB 0을 시간=0부터 시간=7까지 기계 1번에 할당한다.
JOB 1을 시간=0부터 시간=6까지 기계 2번에 할당한다.
JOB 2을 시간=0부터 시간=5까지 기계 3번에 할당한다.
JOB 3을 시간=6부터 시간=10까지 기계 3번에 할당한다.
JOB 4을 시간=7부터 시간=9까지 기계 2번에 할당한다.
JOB 5을 시간=8부터 시간=9까지 기계 1번에 할당한다.
JOB 6을 시간=10부터 시간=10까지 기계 2번에 할당한다.
```

<img src = "https://user-images.githubusercontent.com/98953721/202066480-0809c257-fcae-4867-b3b8-45d376e56b26.png" width = 800 height = 150>

# **[10장] 그래프I**
## **1. 그래프란?**
- 연결되어 있는 객체 간의 관계를 표현하는 자료구조

# **2. 그래프의 정의/ 용어**
### **2-1. 그래프의 정의**
- 정점(vertex)과 간선(edge)들의 유한 집합
- G = (V,E)

- **정점(vertex)**
  - 여러 가지 특성을 가질 수 있는 객체
  - V(G): 그래프 G의 정점들의 집합
  - 노드(node)라고도 불림
  
- **간선(edge)**
  - 정점들 간의 관계
  - E(G): 그래프 G의 간선들의 집합
  - 링크(link)라고도 불림
<img src = "https://user-images.githubusercontent.com/98953721/205488157-af0720a5-476a-4dcd-83f1-0bb9c036b006.png" width = 250 height = 150>

- 그래프 표현의 예
<img src = "https://user-images.githubusercontent.com/98953721/205488271-13bc341a-49c4-4b3f-8d87-93e61379c820.png" width = 600 height = 350>

### **2-2. 그래프의 종류**
- 무방향 그래프(undirected graph)
  - 간선을 통해서 **양방향**으로 갈 수 있는 그래프
  - 간선을 정점의 쌍으로 표현 ---> (A,B)
  - (A,B)와 (B,A)는 **동일한** 간선 
- 방향 그래프(directed graph)
  -  간선에 방향성이 존재하는 그래프
    - 간선의 한쪽 방향으로만 갈 수 있음
    - 정점 A to 정점 B: <A,B>
  - 방향 그래프에서 <A,B>와 <B,A>는 서로 **다른** 간선 
  
<img src = "https://user-images.githubusercontent.com/98953721/205488465-2a9e5331-dd03-4e54-9e36-257bdabeb603.png" width = 600 height = 250>

### **2-3. 네트워크**
- 가중치 그래프(weighted graph)
- 간선에 비용(cost)이나 가중치(weight)가 할당된 그래프 --- 연결 **강도** 표시
<img src = "https://user-images.githubusercontent.com/98953721/205488572-0e74fef5-ea18-4bda-b0a9-af5f9015c3e8.png" width = 250 height = 150> 

### **2-4. 부분 그래프(sub graph)**
- 어떤 그래프의 정점의 일부와 간선의 일부로 이루어진 그래프
<img src = "https://user-images.githubusercontent.com/98953721/205488674-584ad0c7-3b93-4ef1-ae37-f666a0619b35.png" width = 600 height = 300>

### **2-5. 정점의 차수**
- 인접 정점(adjacent vertex)
	- 하나의 정점에서 간선에 의해 직접 연결된 정점
	- G1에서 정점 0의 인접 정점: 정점 1, 정점 2, 정점 3
- 무방향 그래프의 차수(degree)
	- 하나의 정점에 연결된 다른 정점의 수
	- G1에서 정점 0의 차수: 3
	- 무방향 그래프에서 모든 정점의 차수를 합하면 간선 수의 **2배**가 됨
- 방향 그래프의 차수(degree)
	- 진입 차수(in-degree): 외부에서 오는 간선의 수
	- 진출 차수(out-degree): 외부로 향하는 간선의 수
	- G3에서 정점 1의 차수: 내차수 1, 외차수 2
	- 방향 그래프의 모든 진입(진출) 차수의 합 = 간선의 수

### **2-6. 경로**
- 무방향 그래프의 정점 s로부터 정점 e까지의 경로
	- 정점의 나열: s, v1, v2, ..., vk, e
	- 나열된 정점들 간에 반드시 간선 (s,v1), (v1,v2). ... , (vk,e) 존재
- 단순 경로(simple path)
	- 경로 중에서 반복되는 간선이 없는 경로
- 사이클(cycle)
	- 단순 경로의 시작 정점과 종료 정점이 동일한 경로
<img src = "https://user-images.githubusercontent.com/98953721/205489225-88090676-6e0c-4e77-8b20-f76bf1c669c2.png" width = 600 height = 350>

### **2-7. 그래프의 연결 정도**
- 연결 그래프(connected graph)
	- 무방향 그래프 G에 있는 모든 정점 쌍에 대하여 항상 경로 존재
	- G2: 비연결 그래프
<img src = "https://user-images.githubusercontent.com/98953721/205489356-7936706a-370e-4f11-a67c-9deb72e1ba5f.png" width = 400 height = 150> 

- 완전 그래프(complete graph)
	- 그래프 내의 모든 정점들이 연결되어 있는 그래프
	- n개의 정점을 가진 무방향 완전 그래프의 간선의 수: n*(n-1)/2 


## **3. ⭐ 그래프 표현 방법**
### **3-1. 인접 행렬(adjacent matrix)**
- 2차원 배열을 사용하여 그래프를 표현
- 정점의 수가 n인 그래프를 n * n의 2차원 배열인 **인접 행렬** M의 각 원소를 다음의 규칙에 의해 할당함으로써 그래프를 메모리에 표현할 수 있음

```
if(간선 (i,j)가 그래프에 존재) M[i][j] = 1,
otherwise                    M[i][j] = 0
```

- n개의 정점을 가지는 그래프를 인접 행렬로 표현하기 위해서는 간선의 수에 무관하게 항상 n^2개의 메모리 공간이 필요함
	- 그래프에 간선이 많이 존재하는 **밀집 그래프(dense graph)** 표현에 적합
	- 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프(sparse graph)의 경우 메모리의 낭비가 크므로 적합하지 않음
	- 인접 행렬 이용 시 두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 즉시 알 수 있음
		- M[u][v]의 값 조사 시 정점 u와 정점 v를 연결하는 정점의 존재 여부를 파악할 수 있음
	- 정점의 차수: 인접 행렬의 행이나 열 조사 시 파악 가능 ---> 시간 복잡도: O(n)
		- 인접 배열의 i번째 행이나 열에 있는 값들을 모두 더하면 됨
	- 그래프에 존재하는 모든 간선의 수를 파악하려면 인접 행렬 **전체**를 조사해야 함
		- 시간 복잡도: O(n^2)
  
<img src = "https://user-images.githubusercontent.com/98953721/205489814-2b084ca7-ac6f-4932-94f1-bb8658db196f.png" width = 600 height = 300>

### **3-2. 인접 리스트(adjacent list)**
- 각 정점에 인접한 정점들을 연결 리스트로 표현
	- 각 연결 리스트의 노드들은 인접 정점을 저장하게 됨
- 간선의 개수가 적은 희소 그래프(sparse graph) 표현에 적합함

<img src = "https://user-images.githubusercontent.com/98953721/205491841-88f79824-bddf-491f-a1f0-ddc40fb0a0e6.png" width = 700 height = 500>


# **[12장] 정렬**

## **1. 정렬이란?**
### **1-1. 정렬(Sorting)**
- 물건을 크기순으로 오름차순이나 내림차순으로 나열하는 것
- 컴퓨터공학에서 가장 기본적이고 중요한 알고리즘 중 하나
- 정렬은 자료 탐색에 있어서 필수적

### **1-2. 정렬의 대상**
- 정렬시켜야 할 대상: **레코드(record)**
- 레코드는 필드(field)라는 더 작은 단위로 구성
- 키(key) 필드로 레코드들을 구분  
=> 정렬: 레코드들을 키값의 순서로 재배열
<img src="https://user-images.githubusercontent.com/98953721/202898954-40a9f3d9-38fe-4d5a-aed5-172333ca4f8f.png" width="500" height="200">

- 모든 경우에 최적인 정렬 알고리즘은 존재하지 x  
  - 각 응용 분야에 적합한 정렬 방법을 선택해야 함

### **1-3. 정렬 알고리즘의 평가 기준**
- 비교 연산의 횟수 & 이동 연산의 횟수
  - 단순하지만 비효율적인 방법: 삽입 정렬, 선택 정렬, 버블 정렬
  - 복잡하지만 효율적인 방법: 퀵 정렬, 히프 정렬, 합병 정렬, 기수 정렬 등
- **안정성(stability)**  
  - 입력 데이터에 동일한 키값을 갖는 레코드가 여러 개 존재할 경우, 이들 레코드들의 상대적인 위치가 정렬 후에도 바뀌지 않음
  - 정렬의 안정성이 필수적으로 요구되는 경우 **삽입정렬, 버블정렬, 합병정렬** 등을 사용해야 함
 <img src="https://user-images.githubusercontent.com/98953721/202899858-86e63273-cde6-48d7-b259-fc60e5ed9d8a.png" width="400" height="200">
 
 ## **2. 선택 정렬(Selection Sort)**
 ### **2-1. 선택 정렬의 원리**
 - 왼쪽 리스트: 정렬이 완료된 숫자들 / 오른쪽 리스트: 정렬되지 않은 숫자들이 있다고 가정
  - 초기 상태에서 왼쪽 리스트는 비어 있고, 정렬되어야 할 숫자들은 모두 오른쪽 리스트에 들어 있음
 - 오른쪽 리스트에서 가장 **작은** 숫자를 선택하여 왼쪽 리스트로 이동하는 작업을 되풀이
 - 오른쪽 리스트가 공백상태가 될 때까지  
<img src="https://user-images.githubusercontent.com/98953721/202900336-22c480ac-4a20-4eab-b21a-8ae80b7a643f.png" width="600" height="300">

- **제자리 정렬(in-place sorting)**  
  - 입력 배열 이외에는 다른 추가 메모리를 요구하지 않는 정렬 방법
  <img src="https://user-images.githubusercontent.com/98953721/202900544-a5603981-fe60-410d-a78b-049c8945f9e6.png" width="450" height="360">

### **2-2. 선택 정렬 알고리즘**
- list[0]부터 list[n-2]까지 정렬이 되어있는 경우 이미 list[n-1]이 가장 큰 값이다.  
  => 인덱스 값이 **0 ~ (n-2)** 까지만 변함

### **2-3. 선택 정렬 분석**
- 비교 횟수: (n-1) + (n-2) + (n-3) + ... + 1 = n(n-1)/2 => O(n^2)
- 이동 횟수: 한 번 swap 시 3번의 이동이 필요 -> 3(n-1)

- 장점: 자료의 이동 횟수가 미리 결정됨
- 단점
	- 이동 횟수 자체가 상당히 크다.
	- 자료가 정렬된 이후에는 불필요하게 자기 자신과의 이동을 하게 됨
		- 다음과 같은 if문 추가 시 개선 가능
		```C
		if(i != least)
			SWAP(list[i],list[least],temp);
		```
	- 안정성을 만족하지 않음


## **3. 삽입 정렬(Insertion Sort)⭐⭐**
### **3-1. 삽입 정렬의 원리**
- 정렬되어 있는 부분에 새로운 레코드를 옳은 위치에 삽입하는 과정을 반복
- 선택 정렬과 비슷하게 입력 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어서 사용하면 됨
	- 정렬되지 않은 부분이 빌 때까지 반복 
- 예시
<img src="https://user-images.githubusercontent.com/98953721/202904458-4a2e2ee1-72c8-4907-9f07-6632c5584017.png" width="450" height="360">

- 알고리즘  
	1. 인덱스 1부터 시작(인덱스 0은 이미 정렬된 것으로 간주)  
	2. 현재 삽입될 숫자인 i번째 정수를 key 변수로 복사  
	3. 현재 정렬된 배열은 (i-1)까지임 -> (i-1)번째부터 역순으로 조사  
	4. j값이 음수가 아니고 key값보다 정렬된 배열에 있는 값이 크면  
	5. j번째 -> (j+1)번째  
	6. j 하나 감소  
	7. j번째 정수가 key보다 작음 -> (j+1)번째가 key값이 들어갈 위치  
<img src="https://user-images.githubusercontent.com/98953721/202904778-56153285-4f96-43a3-b208-33c480872986.png" width="600" height="900">

### **3-2. 삽입 정렬의 복잡도 분석**
- 최선: 이미 정렬이 되어 있는 경우
	- 각 단계에서 1번의 비교와 2번의 이동 => 총 (n-1)번의 비교, 총 2(ㅜ-1)번의 이동 => 시간 복잡도: O(n)
- 최악: 역순으로 정렬되어 있는 경우
	- 모든 단계에서 앞에 놓인 자료를 전부 이동시켜야 함
	- 총 비교 횟수: 1 + 2 + ... + (n-1) = n(n-1)/2 => O(n^2)
	- 총 이동 횟수: 각 단계마다 (i+2)번의 이동 => n(n-1)/2 + 2(n-1)  = (n^2 + 3n - 4)/2 => 시간 복잡도: O(n^2)
- 삽입 정렬은 비교적 많은 레코드들의 이동을 포함, 요소들이 이웃한 위치로만 이동 -> 레코드가 클 경우 불리
- 안정한 정렬 방법 -> 대부분의 레코드가 이미 정렬되어 있는 경우 매우 효율적


## **4. 버블 정렬(Bubble Sort)⭐⭐**
### **4-1. 버블 정렬의 원리**
- 인접한 2개의 레코드를 비교해서 순서대로 되어 있지 않으면 서로 교환 --- **비교-교환 과정(스캔)**
- 리스트의 왼쪽 끝에서 시작 -> 오른쪽 끝까지 진행
<img src="https://user-images.githubusercontent.com/98953721/202905637-a091394e-85a3-46d1-8293-564de6eae8db.png" width="400" height="600">

- 스캔을 반복해서 수행 -> 왼쪽 리스트가 빌 때까지 진행

### **4-2. 알고리즘**
- 하나의 스캔: j = 0 -> j = (i-1)
- j번째 요소와 (j+1)번째 요소를 비교하여 크기순으로 되어 있지 않으면 교환

### **4-3. 버블 정렬의 복잡도 분석**
- 비교 횟수: 항상 일정 -> 1 + 2 + ... + (n-1) = n(n-1)/2 => 시간 복잡도: O(n^2)
- 이동 횟수
	- 최악: 3 * (n(n-1)/2) --- SWAP이 3번의 이동을 포함
	- 최선: 입력 자료가 이미 정렬이 되어 있는 경우 --- 이동이 한 번도 발생x
	- 평균적인 경우에는 자료 이동이 0번에서 i번까지 같은 확률로 발생할 것임 -> 시간 복잡도: O(n^2)
- 가장 큰 단점은 순서에 맞지 않은 요소를 인접한 요소와 계속해서 교환한다는 점
	- 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서 배열의 모든 다른 요소들과 교환되어야 함
	- 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 발생하기도 함
	
## **5. 쉘 정렬(Shell Sort)**
### **5-1. 쉘 정렬의 원리**
- 삽입 정렬이 어느 정도 정렬된 리스트에서 대단히 빠르게 진행되는 것에 착안
- 삽입 정렬의 O(n^2)보다 빠름
- 먼저 정렬해야 할 리스트를 일정 간격(gap)의 **부분 리스트**로 나누고, 각 부분 리스트를 **삽입 정렬**을 통해 정렬
	- 부분 리스트의 개수가 1이 될 때까지 되풀이
<img src="https://user-images.githubusercontent.com/98953721/202906826-89b407c9-21cc-405d-ad9a-af30882d17bc.png" width="800" height="900">

### **5-2. 쉘 정렬의 분석**
- 장점
	1. 불연속적인 부분 리스트에서 원거리 자료 이동으로 보다 적은 위치 교환으로 제자리를 찾을 가능성이 높아짐
	2. 부분 리스트가 점진적으로 정렬된 상태가 됨 -> 삽입 정렬의 속도 증가

- 시간 복잡도
	- 최악: O(n^2)
	- 평균: O(n^1.5)


## **6. 합병 정렬(Merge Sort)⭐⭐**
### **6-1. 합병 정렬의 개념**
- 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합쳐서 전체 리스트 정렬
- 분할 정복 기법 활용
	- **분할 정복(divide and conquer)**
		- 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략
		- 대부분 순환 호출로 구현
		- 단계
			1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할
			2. 정복(Conquer)
				- 부분 배열을 정렬
				- 부분 배열의 크기가 충분히 작지 않으면 **순환 호출**을 통해 다시 분할 정복 기법 적용
			3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 통합
			
 <img src="https://user-images.githubusercontent.com/98953721/203103575-08335768-0686-4584-bcf1-d46a650ad3c8.png" width="400" height="300">
 <img src="https://user-images.githubusercontent.com/98953721/203103973-fbbe1e58-8a45-4821-a790-45bb3c589381.png" width="600" height="700">

### **6-2. 알고리즘**
1. 만약 나누어진 구간의 크기가 1 이상이면
2. 중간 위치 계산
3. 앞쪽 부분 배열 정렬 --- merge_sort() 순환 호출
4. 뒤쪽 부분 배열 정렬 --- merge_sort() 순환 호출
5. 정렬된 2개의 부분 배열을 통합 -> 하나의 정렬된 배열로

<img src="https://user-images.githubusercontent.com/98953721/203105129-4ca3283f-ef66-4165-abd9-49641280dd09.png" width="650" height="500">
<img src="https://user-images.githubusercontent.com/98953721/203105710-c8aba7ae-2e22-440e-8418-89fdbd803612.png" width="350" height="250">


### **6-3. 합병 정렬 구현**
**[알고리즘]**
1. merge_sort()에서 주어진 list 배열을 이등분하여 각각의 부분 배열에 대하여 다시 merge_sort() 함수를 **순환 호출**
2. 부분 배열에 숫자가 하나 남을 때까지 1 반복
3. 분할 과정 완료 => 정렬된 부분 배열을 merge()를 이용해 합병 --- 실제로 숫자들이 **정렬**되는 곳
4. merge()를 통해 정렬된 부분 배열들의 임시 숫자 배열을 다시 원래의 배열에 복사

<img src="https://user-images.githubusercontent.com/98953721/203113956-6760eace-6b8d-4db8-b77a-1a113ec22fa1.png" width="350" height="250">

### **6-4. 합병 정렬의 복잡도 분석**
- 레코드의 개수(n): 2의 거듭제곱이라 가정
- 순환 호출의 깊이: n = 2^k인 경우 2^k -> 2^(k-1) -> ... -> 2^0 => 깊이: k, k = log2(n)
- 배열이 부분 배열로 **나누어지는** 단계에서는 비교/이동 연산 수행 x
- 부분 배열이 **합쳐지는** merge()에서 비교/이동 연산 수행

- 하나의 합병 단계
	- 최대 n번의 비교 연산 -> 총 비교 연산: 최대 n * log2n 번 필요  
	- 총 부분 배열에 들어 있는 요소의 개수가 n인 경우 최대 2n번의 이동 -> 총 이동 연산: 2n * log2n번 필요  
=> 시간 복잡도: O(nlog2n)

### **6-5. 합병 정렬의 장/단점**
- 장점  
	- 안정적인 정렬 방법  
	- 데이터의 분포에 영향을 덜 받음  
- 단점  
	- 정렬 결과를 저장할 임시 배열 필요  
	- 만약 레코드들의 크기가 큰 경우에는 이동 횟수가 많음 -> 큰 시간적 낭비 초래  
		=> **연결 리스트**를 통해 개선 가능


## **7. 퀵 정렬(Quick Sort)⭐⭐**
### **7-1. 퀵 정렬의 개념**  
- 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법  
- **분할 정복법**에 근거  
	- 전체 리스트를 2개의 부분 리스트로 분할하고, 각각의 부분 리스트를 다시 퀵 정렬(**재귀 호출**)  
	- 합병 정렬과는 다르게 **비균등** 분할 수행  
	- 리스트의 요소 중 하나를 **피벗(pivot)** 으로 설정 -> 피벗을 기준으로 분할   
		=> 피벗보다 **작은** 요소들을 왼쪽으로, **큰** 요소들을 오른쪽으로  
	- 분할된 상태에서 피벗을 제외한 왼쪽/오른쪽 리스트를 각각 정렬  

<img src="https://user-images.githubusercontent.com/98953721/203118117-78026148-d976-4d6b-b880-14075edc660e.png" width="350" height="250">

### **7-2. 퀵 정렬 알고리즘**
1. 정렬할 범위가 2개 이상의 데이터이면
2. partition() 호출 -> 피벗을 기준으로 2개의 리스트로 분할  
   =>  partition() 함수의 반환값: 피벗의 위치
3. left에서 피벗 위치 바로 앞까지를 대상으로 순환 호출(이때, 피벗은 제외)
4. 피벗 위치 바로 다음부터 right까지를 대상으로 순환 호출(이때, 피벗은 제외)

<img src="https://user-images.githubusercontent.com/98953721/203239733-e7fcee06-3e6c-4ee1-9ccd-962c6d82a3f5.png" width="650" height="800">

### **7-3. 퀵 정렬의 복잡도 분석**
- 최선: 거의 균등한 리스트로 분할되는 경우
  - 패스 수: n/n^k = 1일 때까지 계속 2분할 -> k = log2(n) 개의 패스  
  - 각각의 패스에서는 전체 리스트의 대부분의 레코드를 비교   
  => 총 nlog2(n)번 비교, 시간 복잡도: O(nlog2n)  
  - 총 이동횟수는 비교횟수에 비해 적으므로 무시 가능
  
- 최악: 극도로 불균등한 리스트로 분할되는 경우
  - 패스 수: n
  - 각 패스에서 n번의 비교  
  => n^2번의 비교 연산, 시간 복잡도: O(n^2)  
  - 이미 정렬된 리스트에 대하여 퀵 정렬을 실행 시 첫 번째 레코드를 피벗으로 설정한 경우 왼편 리스트가 텅 비게 되는 **불균형 분할**이 연속해서 발생
  ```
  (1 2 3 4 5 6 7 8 9)
  1 (2 3 4 5 6 7 8 9)
  1 2 (3 4 5 6 7 8 9)
  1 2 3 (4 5 6 7 8 9)
  1 2 3 4 (5 6 7 8 9)
  ...
  1 2 3 4 5 6 7 8 9
  ```

### **7-4. 퀵 정렬의 장/단점**
- 장점
  - 속도 fast
  - 추가 메모리 공간 요구x
- 단점
  - 정렬된 리스트에 대해서는 오히려 수행시간이 더 많이 걸림  
=> 완화) **중간값**을 피벗으로 선택하여 분균등 분할 완화 가능    


## **8. 기수 정렬(Radix Sort) --- 중요도 ↓**

### **8-1. 기수 정렬의 원리**
- 대부분의 정렬 방법들은 레코드들을 비교함으로써 정렬을 수행
- 기수 정렬은 레코드 비교 수행 x
  - 비교에 의한 정렬의 하한인 **O(n * log(n))** 보다 좋을 수 O
  - **O(dn)** 정도의 시간 복잡도(대부분 d < 10, d: 정수, n: 정수)  
(이하생략)  

## **9. 정렬 알고리즘의 비교 ⭐⭐⭐**
<img src="https://user-images.githubusercontent.com/98953721/203248606-17a38f9c-9571-4933-9065-d149520f8ecd.png" width="1100" height="350">


# **[13장] 탐색**
## **1. 이진 탐색 트리(Binary Search Tree)**
- 이진 탐색과 이진 탐색 트리는 근본적으로 같은 원리에 의한 탐색 구조
- 이진 탐색(binary search)
	- 자료들이 배열에 저장됨
	- 자료의 삽입/삭제 시 앞뒤의 원소들을 이동시켜야 함 -> 삽입/ 삭제의 어려움
- 이진 탐색 트리(binary search tree)
	- 비교적 빠른 시간 안에 삽입/삭제 가능
	- 삽입/삭제가 빈번히 발생하는 상황에 적합한 자료구조
- 이진 탐색 트리에서의 시간 복잡도
	- 균형 트리: O(log(n))
	- 불균형 트리: O(n) --- 순차 탐색과 동일/ 선형

## **2. AVL 트리**
- 각 노드에서 왼쪽 서브 트리의 높이와 오른쪽 서브 트리의 높이 차가 1 이하인 이진 탐색 트리
- 트리가 비균형 상태로 되면 스스로 노드들을 재배치하여 균형 상태로 만듦  
	- 균형 트리가 항상 보장됨 -> 탐색이 O(log(n)) 시간 안에 끝나게 됨  
	- 삽입/삭제 연산도 동일한 시간 복잡도를 가짐  
	  => 평균,최선,최악 시간 복잡도: O(log(n))  
- 균형 인수(balance factor)  
	- (왼쪽 서브 트리의 높이) - (오른쪽 서브 트리의 높이)  
	- 모든 노드의 균형 인수가 **-1 <= (균형 인수) <= 1**이면 AVL 트리  
<img src = "https://user-images.githubusercontent.com/98953721/204974041-1a9daf3e-a6da-4c60-8fa0-faf9d6ca5602.png" width = 500 height = 200> 

### **2-1. AVL 트리의 연산**
**✔ 탐색 연산**  
- 일반적인 이진 탐색 트리와 동일
- 시간 복잡도: O(log_2(n))  

**✔ 삽입/삭제 연산**  
- 삽입/ 삭제 연산 시 균형 상태가 깨질 수 있음
- 삽입 연산
	- 삽입 연산 시 삽입 위치에서 루트까지의 경로에 있는 조상 노드들의 균형 인수에 영향
	- 삽입 연산 후 불균형 상태로 변한 가장 가까운 조상 노드(균형 인수가 +2 또는 -2가 된 가장 가까운 조상 노드)의 서브트리들에 대해 다시 배치하여 균형 상태로 만듦
		- 삽입 노드부터 균형 인수가 +2 또는 -2가 된 가장 가까운 조상 노드까지 **회전**  
		- 다른 노드들은 변경할 필요 x  

### **2-2. AVL 트리의 삽입 연산 - 4가지 경우**
- J: 새로 삽입한 노드
- X: 새로 삽입된 노드(J)로부터 가장 가까우면서 균형 인수가 +2 또는 -2가 된 조상 노드
- LL 타입: 오른쪽 회전
- LR 타입: 왼쪽 회전 -> 오른쪽 회전
- RR 타입: 왼쪽 회전
- RL 타입: 오른쪽 회전 -> 왼쪽 회전
<img src = "https://user-images.githubusercontent.com/98953721/205233994-1b526de1-aeb4-4581-8feb-2a2d1ee5541e.png" width = 800 height = 450> 


##### **LL 타입**
- 노드 X의 왼쪽 자식의 왼쪽에 노드 추가 시 발생
- 노드들을 오른쪽으로 회전
<img src = "https://user-images.githubusercontent.com/98953721/204976663-d1e52c56-c7a6-4037-8a7a-8233bd0f7b9a.png" width = 300 height = 150> 

##### **RR 타입**
- 노드 X의 오른쪽 자식의 오른쪽에 노드 추가 시 발생
- 노드들을 왼쪽으로 회전
<img src = "https://user-images.githubusercontent.com/98953721/204977418-710f65ac-e13f-4273-ab29-df7ed488bf0b.png" width = 300 height = 150> 

##### **RL 타입**
- 노드 X의 오른쪽 자식의 왼쪽에 노드가 추가 시 발생
- 오른쪽 회전 -> 왼쪽 회전  
  ⭐ 오른쪽 회전 시 J와 Y의 위치가 바뀜  
<img src = "https://user-images.githubusercontent.com/98953721/204977703-f2c03a0e-6a57-44ef-bd37-9171b9d8871b.png" width = 400 height = 150> 

##### **LR 타입**
- 노드 X의 왼쪽 자식의 오른쪽에 노드 추가 시 발생
- 왼쪽 회전 -> 오른쪽 회전  
  ⭐ 왼쪽 회전 시 J와 Y의 위치가 바뀜  
<img src = "https://user-images.githubusercontent.com/98953721/205234825-1a728615-c687-4f7d-ac93-5aeefc7b7d21.png" width = 400 height = 150> 

### **2-3. AVL 트리 예제**
<img src = "https://user-images.githubusercontent.com/98953721/205235543-4dba587e-14b4-4527-a9d5-2d39b20945e8.png" width = 600 height = 400>

# **[14장] 해싱**
## **1. 해싱이란?**
- 대부분의 탐색 방법들은 키 값을 비교함으로써 탐색하고자 하는 항목에 접근함
	- 빠른 검색을 하고자 노력 
### **1-1. 해싱(Hashing)**
- 키(key) 값에 대한 산술적 연산에 의해 테이블의 주소를 계산하여 주소로 바로 항목에 접근하는 방법
	- 키 비교 연산 수행x 
- **해시 테이블(Hash table)**: 키 값의 연산에 의해 직접 접근이 가능한 구조
- 사전(dictionary) 자료구조 활용  
<img src = "https://user-images.githubusercontent.com/98953721/205308422-364ead29-ebd7-44f8-9357-98c2c520eb3b.png" width = 400 height = 200>

## **2. 추상 자료형 사전**
### **2-1. 사전의 개념**
- **사전(dictionary)**: (키, 값) 쌍의 집합
	- 키(key): 사전의 단어처럼 항목과 항목을 구별시켜주는 것
	- 값(value): 단어에 대한 설명에 해당됨 	
- 맵(map)이나 테이블(table)로 불리기도 함
- 무조건 **키**에 의하여 항목에 접근할 수 있어야 함(정렬 여부와 무관)

### **2-2. 사전의 연산**
- 객체: 일련의 (key, value) 쌍의 집합
- 연산:
	- add(key, value): (key, value)를 사전에 추가
	- delete(key)
		- key에 해당되는 (key, value)를 찾아서 삭제
		- 관련된 value 반환
		- 탐색 실패 시 NULL을 반환
	- search(key)
		- key에 해당되는 value를 찾아서 반환
		- 탐색 실패 시 NULL을 반환

## **3. 해싱의 구조**
- 해싱에서는 자료를 저장하는 데 **배열**을 활용
	- 어떤 항목의 키만을 가지고 바로 항목이 들어 있는 배열의 인덱스를 결정하는 기법

### **3-1. 해시 함수(hash function)**
- 탐색 키를 입력받아 해시 주소를 생성하고, 이를 해시 테이블의 인덱스로 사용할 수 있도록 하는 함수
<img src = "https://user-images.githubusercontent.com/98953721/205313303-b0b7179d-349f-4ffd-b4e1-aab1df44ec08.png" width = 400 height = 250>

### **3-2. 해시 테이블의 구조**

**해시 테이블 ht**  
	- M개의 **버켓(bucket)** 으로 구성된 테이블
	- ht[0], ht[1], ... , ht[M-1]의 원소를 가짐
	- 하나의 버켓은 s개의 슬롯(slot)을 가질 수 있음
		- 서로 다른 두 개의 키가 해시 함수에 의해 동일한 해시 주소로 변환될 수 있기에, 여러 개의 항목을 동일한 버킷에 저장하기 위함임
		- 하나의 슬롯에 하나의 항목이 저장됨
	- 그러나 대부분의 경우 하나의 버킷은 하나의 슬롯을 가짐
	<img src = "https://user-images.githubusercontent.com/98953721/205316851-53aa824a-73fd-42eb-ae9a-e87ddb49f93f.png" width = 200 height = 300>

**충돌(collision)**  
	- 서로 다른 두 개의 탐색 키 k1과 k2에 대해 h(k1) = h(k2)인 경우  
    - 해시 테이블에서의 인덱스가 동일  
	- 충돌 발생 시 동일 버킷 내의 다른 슬롯에 항목 저장  
	- 충돌이 자주 발생하면 버킷 내부에서의 순차 탐색 시간이 길어짐 -> 탐색 성능 저하    
		=> 해시 함수 수정 or 해시 테이블 크기 조정 필요    
		
**오버플로우(overflow)**  
	- (충돌 수) > (버켓에 할당된 슬롯 수)
	- 더 이상 항목을 저장할 수 없음 -> 해결 필요

### **3-3. 이상적인 해싱**
- 학생 정보를 해싱으로 저장/탐색하는 상황
	- 학번 5자리 중 앞 2자리는 학과 번호, 뒤 3자리가 각 학과의 학생 번호
	- 같은 학과 학생들만 있다고 가정하면 뒤의 **3자리만** 사용해서 탐색 가능
	- 학번이 00023이라면 해당 학생의 인적사항은 해시 테이블 h[23]에 저장됨
	- 만약 해시 테이블이 1000개의 공간(000 ~ 999)을 가지고 있다고 하면 탐색 시간이 O(1)이 되므로 이상적  
		- 하나의 학번 당 하나의 배열 요소 할당  

### **3-4. 실제의 해싱**
- 실제로는 해시 테이블의 크기가 제한되어 있음    
	=> 하나의 키 당 해시 테이블에서 하나의 공간을 할당할 수가 없음  
- 필연적으로 충돌과 오버플로우 발생  
  => 실제의 해싱에서의 시간 복잡도는 O(1)보다는 떨어짐     

## **4. 해시 함수**
### **4-1. 좋은 해시 함수의 조건**
- 충돌이 적어야 함
- 해시 함수 값이 해시 테이블의 주소 영역 내에서 고르게(균일하게) 분포되어야 함
- 계산이 빨라야 함
<img src = "https://user-images.githubusercontent.com/98953721/205322061-08c8e834-498c-45dd-8c57-d7b8235ebbfb.png" width = 250 height = 200>

### **4-2. 제산 함수**
- 키를 해시 테이블의 크기로 나눈 **나머지**를 해시 주소로 사용하는 방법
- h(k) = k mod M	※ mod: 나머지 연산  
	- M: 해시 테이블의 크기
- 해시 테이블의 크기 M은 소수(prime number)를 선택  
	- 해시 주소를 상당히 고르게 분포시키기 위함
- 나머지 연산 수행 시 결과로 음수가 나오면 M을 더해줌  
  => 결과값이 항상 0에서 (M-1)이 되도록 함  
- 코드  
```C
int hash_function(int key) {
	int hash_index = key % M;
	if (hash_index < 0)
		hash_index += M;
	return hash_index;
}
```

## **5. 오버플로우 해결 기법**
- **충돌(collision)**: 서로 다른 키를 갖는 항목들이 같은 해시 주소를 가지는 현상(인덱스 동일)
- 충돌이 발생하고, 해시 주소에 더 이상 빈 버킷이 남아있지 않으면 오버플로우 발생
- 오버플로우 발생 시 해시 테이블에 항목을 더 이상 저장할 수 없음
- 오버플로우를 해결하는 방법이 요구됨 

### **5-1. 체이닝(Chaining)**
- 해시 테이블에서 하나의 위치(인덱스)가 여러 개의 항목을 저장할 수 있도록 해시 테이블의 구조를 변경하는 방법
- 오버플로우 문제를 **연결 리스트**로 해결
	- 각 버켓에 고정된 슬롯이 할당되어 있지 않음 
	- 각 버켓에 삽입/삭제가 용이한 연결 리스트 할당
	- 버켓 내에서는 연결 리스트를 순차 탐색

<img src = "https://user-images.githubusercontent.com/98953721/205327428-e85ae509-2660-469c-85d8-cc607f6b3fbf.png" width = 650 height = 500>

### **5-2. 개방 주소법(Open Addressing)**
- 특정 버킷에서 충볼 발생 시 비어있는 버킷을 찾는 방법
	- 조사(probing): 해시 테이블에서 비어있는 공간을 찾는 것 
- 종류

	**a. 선형 조사법(linear probing)**  
	- k번째부터 시작해 비어있는 공간이 나올 때까지 계속하여 조사하는 방법
	- 테이블의 끝에 도달하게 되면 다시 테이블의 처음부터 조사 --- 원형으로 회전
	- 만약 조사를 시작했던 곳으로 되돌아오게 되면 테이블이 가득 찬 것으로 판단
	<img src = "https://user-images.githubusercontent.com/98953721/205429348-46e7ccc6-a960-468a-a4fe-f4bac82e3f28.png" width = 600 height = 200>  
	
  - 군집화와 결합 문제 발생  
		- 군집화(clustering): 해시 테이블에서 한 번 충돌이 시작되면 그 위치에 항목들이 집중되는 현상  
		- 결합(coalescing): 집중된 항목들이 결합하는 현상  
	
  
  **b. 이차 조사법(quadratic probing)**  
	- 선형 조사법과 유사하지만, 다음 조사할 위치를 다음 식에 의해 결정함
		<image src = "https://user-images.githubusercontent.com/98953721/205431347-9654e183-8543-4f34-9b65-861d6656687d.png" width = 400 height = 30>
  
	- 조사되는 위치: h(k), h(k)+1, h(k)+4, h(k)+9, ...
  - 모든 위치를 조사하게 하려면 여전히 테이블 크기는 **소수**여야 함
	- 선형 조사법의 집중/결합 문제를 크게 완화시킬 수 있음
  
  **c. 이중 해싱법(double hashing/ 재해싱 - rehashing)**  
	- 오버플로우가 발생함에 따라 항목을 저장할 다음 위치 결정 시 원래 해시 함수와 다른 **별개**의 해시 함수를 이용하는 방법  
	- 항목들을 해시 테이블에 보다 균일하게 분포시킬 수 있는 효과적인 방법  
	- 키를 참조하여 더해지는 값이 결정됨  
		- 해시 함수값이 같더라도 키가 다르면 서로 다른 조사 순서  
	- 첫 번째 해시 함수: 원래의 해시 함수 => 키를 해시 테이블의 index로   
	- 두 번째 해시 함수: h'(k) = C - (k mod C) (C: 테이블의 크기인 M보다 약간 작은 소수)  
	- 충돌 발생 시 조사 위치: h(k), h(k) + h'(k), h(k) + 2 * h'(k), h(k) + 3 * h'(k), ...  
	
	<img src = "https://user-images.githubusercontent.com/98953721/205431837-6cb3bcab-c2d2-4d90-a9f5-ea4efdee74c4.png" width = 600 height = 400>
	

## **6. 해싱의 성능 분석**
- 이상적인 해싱의 시간 복잡도: O(1)
	- 충돌이 전혀 일어나지 않는다는 가정 하에서만 가능
- 해싱의 성능을 분석하기 위한 척도: 적재 밀도(loading density) 또는 적재 비율(loading factor)
	- 저장되는 항목의 개수(n)와 해시 테이블 크기(M)의 비율
	- α = (저장된 항목의 개수) / (해시 테이블의 버킷의 개수) = n / M
	- α = 0: 해시 테이블이 비어있는 상태
	
- 탐색을 위한 비교 연산의 개수
	- 오픈 주소법 
		- 실패: (1/2) * (1 + 1/(1-α)^2)
		- 성공: (1/2) * (1 + 1/(1-α))
	<img src = "https://user-images.githubusercontent.com/98953721/205432378-69600b94-a0d8-45d8-84fd-ae1949ca0148.png" width = 400 height = 300>
	
	- 체이닝 방법
		- 실패: α
		- 성공: 1 + α / 2 
	<img src = "https://user-images.githubusercontent.com/98953721/205432400-8273ab17-492a-4156-af81-b8380bb2619e.png" width = 400 height = 300>
	
<img src = "https://user-images.githubusercontent.com/98953721/205432479-852ded08-1109-4385-b544-d37b07180ba2.png" width = 600 height = 300>
