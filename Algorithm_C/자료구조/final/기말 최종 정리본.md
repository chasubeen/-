# **[7장] 링크드 리스트II**
**⭐ 키워드: 이중 연결 리스트, 음악 재생 프로그램**

## **1. 이중 연결 리스트**
- 응용 프로그램에서 특정 노드의 양방향으로 자유롭게 움직일 필요가 있다면 단순 연결 리스트나 원형 연결 리스트는 부적합  
	-> 이중 연결 리스트를 고안
- 하나의 노드가 선행 노드와 후속 노드에 대한 두 개의 링크를 가지는 리스트
- 장점: 양방향으로 검색이 가능
- 단점: 많은 공간을 차지하고 코드가 복잡해짐

<img src="https://user-images.githubusercontent.com/98953721/200169252-ea3222f0-87e2-4d09-a494-298142ee37cd.png" width = "300" height = "100"/>  
- p = p->llink -> rlink = p->rlink->llink  
  
  => 앞뒤로 똑같이 이동할 수 있음  

### **1-1. 헤드 노드(Head Node)**
- 데이터를 가지고 있지 않은 특별한 노드  
	-> 단지 삽입, 삭제 코드를 간단하게 할 목적으로 만들어진 노드  
- 공백 상태에서는 헤드 노드만 존재  

### **1-2. 노드의 구조**
```C
typedef int element;

typedef struct DlistNode {	// 이중 연결 노드 타입
	element data;             // 데이터 필드
	struct DlistNode *llink;  // 왼쪽 링크 필드 => 선행 노드
	struct DlistNode *rlink;  // 오른쪽 링크 필드 => 후속 노드 
} DlistNode;
```

### **1-3. 삽입 연산**
- 새로 만들어진 노드의 링크는 아무런 정보도 가지고 있지 x  
	-> 새로 만들어진 노드의 링크를 먼저 바꾼다.  
<img src="https://user-images.githubusercontent.com/98953721/200170104-b1383b00-d49b-49e2-9272-7a5a79b0c807.png" width = "450" height = "200"/>  
  
```C
// 새로운 데이터를 선행 노드의 오른쪽에 삽입

void dinsert(DListNode *before, element data){
	DListNode *newnode = (DListNode *)malloc(sizeof(DListNode));
	/*데이터 저장*/
	strcpy(newnode->data, data); // 문자형 데이터라 strcpy() 사용함
	/*링크 생성*/
	newnode->llink = before; // 새로 만들어진 노드의 링크부터 생성
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode; // 후행 노드와 연결
	before->rlink = newnode; // 선행 노드와 연결
}
```

### **1-4. 삭제 연산**
<img src="https://user-images.githubusercontent.com/98953721/200170377-3c7046fb-9cde-4e5f-bec2-5edadcd1de0d.png" width = "450" height = "200"/>  

```C
// 노드 removed를 삭제
void ddelete(DListNode* head, DListNode* removed){
	if (removed == head) return;
	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}
```

### **1-5. 테스트 프로그램**
- 이중 연결 리스트에서는 보통 헤드 노드가 존재함 -> 헤드 포인터 필요 x
- head는 포인터 변수가 아닌 구조체 변수
- 이중 연결 리스트는 사용하기 전에 반드시 초기화를 해야 함  
	-> 헤더 노드의 링크 필드들이 자기 자신을 가리키도록

```C
#include <stdio.h>
#include <stdlib.h>

typedef int element;
typedef struct DListNode { 	// 이중 연결 노드 타입
	element data;
	struct DListNode* llink;
	struct DListNode* rlink;
} DListNode;

/*이중 연결 리스트를 초기화*/
void init(DListNode* phead){
	phead->llink = phead;
	phead->rlink = phead;
}

/*이중 연결 리스트의 노드를 출력*/
void print_dlist(DListNode* phead){
	DListNode* p;
	for (p = phead->rlink; p != phead; p = p->rlink) {
		printf("<-| |%d| |-> ", p->data);
	}
	printf("\n");
}

/*삽입 함수*/
// 새로운 데이터를 노드 before의 오른쪽에 삽입
void dinsert(DListNode* before, element data){
	DListNode* newnode = (DListNode*)malloc(sizeof(DListNode));
	strcpy(newnode->data, data);
	newnode->llink = before;
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode;
	before->rlink = newnode;
}

/*삭제 함수*/
void ddelete(DListNode* head, DListNode* removed){
	if (removed == head) return;
	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}

/*테스트 프로그램*/
int main(void){
	DListNode* head = (DListNode*)malloc(sizeof(DListNode));
	init(head); // 초기화

	printf("추가 단계\n");
	for (int i = 0; i < 5; i++) {
		// 헤드 노드의 오른쪽에 삽입
		dinsert(head, i);
		print_dlist(head);
	}

	printf("\n삭제 단계\n");
	for (int i = 0; i < 5; i++) {
		print_dlist(head);
		ddelete(head, head->rlink);
	}

	free(head);
	return 0;
}
```

# **2. 예제: mp3 재생 프로그램 만들기**

```C
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef char element[100];

/*이중 연결 리스트 구조체 정의*/
typedef struct DlistNode {
	element data;
	struct DlistNode* llink;
	struct DlistNode* rlink;
}DlistNode;

DlistNode* current; // 현재 재생 중인 음악

/*초기화*/
void init(DlistNode* phead) {
	phead->llink = phead;
	phead->rlink = phead;
}

/*출력*/
void print_dlist(DlistNode* phead) {
	DlistNode* p;
	for (p = phead->rlink; p != phead; p = p->rlink) {
		if (p == current)
			printf("<-| #%s# |-> ", p->data);
		else
			printf("<-| %s |-> ", p->data);
	}
	printf("\n");
}

/*삽입*/
void dinsert(DlistNode* before, element data) {
  // 새로운 노드 정의
	DlistNode* newnode = (DlistNode*)malloc(sizeof(DlistNode));
	strcpy(newnode->data, data);
  
	// 링크 생성
	newnode->llink = before;
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode;
	before->rlink = newnode;
}

/*삭제*/
void ddelete(DlistNode* head, DlistNode* removed) {
	if (removed == head) return; // head 노드 삭제 시 링크를 갱신할 필요가 없음

	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}

/*테스트 프로그램*/
int main(void) {
	char ch;
	DlistNode* head = (DlistNode*)malloc(sizeof(DlistNode));
	init(head);

	dinsert(head, "Mamamia");
	dinsert(head, "Dancing Queen");
	dinsert(head, "Fernado");

	current = head->rlink; // 현재 재생중인 음악
	print_dlist(head);

	do {
		printf("\n명령어를 입력하시오(<, >, q): ");
		ch = getchar();
		if (ch == '<') {  // 이전 곡 재생
			current = current->llink;
			if (current == head)
				current = current->llink;
		}
		else if (ch == ">") {  // 다음 곡 
			current = current->rlink;
			if (current == head)
				current = current->rlink;
		}
		print_dlist(head);
		getchar();
	} while (ch != 'q'); // 종료 조건
}
```

### **알고리즘**  
**[dinsert() 원리]**  
<img src = "https://user-images.githubusercontent.com/98953721/206115882-5c49f776-e9c3-4e26-9fde-3740aa2d1468.png" width = 350 height = 150>  

### **실행 결과**
```
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| #Dancing Queen# |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| Dancing Queen |-> <-| #Mamamia# |->

명령어를 입력하시오(<, >, q): >
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): <
<-| Fernando |-> <-| Dancing Queen |-> <-| #Mamamia# |->

명령어를 입력하시오(<, >, q): >
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| #Dancing Queen# |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): <
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): q
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->
```


# **[13장] 탐색**
## **1. 이진 탐색 트리(Binary Search Tree)**
- 이진 탐색과 이진 탐색 트리는 근본적으로 같은 원리에 의한 탐색 구조
- 이진 탐색(binary search)
	- 자료들이 배열에 저장됨
	- 자료의 삽입/삭제 시 앞뒤의 원소들을 이동시켜야 함 -> 삽입/ 삭제의 어려움
- 이진 탐색 트리(binary search tree)
	- 비교적 빠른 시간 안에 삽입/삭제 가능
	- 삽입/삭제가 빈번히 발생하는 상황에 적합한 자료구조
- 이진 탐색 트리에서의 시간 복잡도
	- 균형 트리: O(log(n))
	- 불균형 트리: O(n) --- 순차 탐색과 동일/ 선형

## **2. AVL 트리**
- 각 노드에서 왼쪽 서브 트리의 높이와 오른쪽 서브 트리의 높이 차가 1 이하인 이진 탐색 트리
- 트리가 비균형 상태로 되면 스스로 노드들을 재배치하여 균형 상태로 만듦  
	- 균형 트리가 항상 보장됨 -> 탐색이 O(log(n)) 시간 안에 끝나게 됨  
	- 삽입/삭제 연산도 동일한 시간 복잡도를 가짐  
	  => 평균,최선,최악 시간 복잡도: O(log(n))  
- 균형 인수(balance factor)  
	- (왼쪽 서브 트리의 높이) - (오른쪽 서브 트리의 높이)  
	- 모든 노드의 균형 인수가 **-1 <= (균형 인수) <= 1**이면 AVL 트리  
<img src = "https://user-images.githubusercontent.com/98953721/204974041-1a9daf3e-a6da-4c60-8fa0-faf9d6ca5602.png" width = 500 height = 200> 

### **2-1. AVL 트리의 연산**
**✔ 탐색 연산**  
- 일반적인 이진 탐색 트리와 동일
- 시간 복잡도: O(log_2(n))  

**✔ 삽입/삭제 연산**  
- 삽입/ 삭제 연산 시 균형 상태가 깨질 수 있음
- 삽입 연산
	- 삽입 연산 시 삽입 위치에서 루트까지의 경로에 있는 조상 노드들의 균형 인수에 영향
	- 삽입 연산 후 불균형 상태로 변한 가장 가까운 조상 노드(균형 인수가 +2 또는 -2가 된 가장 가까운 조상 노드)의 서브트리들에 대해 다시 배치하여 균형 상태로 만듦
		- 삽입 노드부터 균형 인수가 +2 또는 -2가 된 가장 가까운 조상 노드까지 **회전**  
		- 다른 노드들은 변경할 필요 x  

### **2-2. AVL 트리의 삽입 연산 - 4가지 경우**
- J: 새로 삽입한 노드
- X: 새로 삽입된 노드(J)로부터 가장 가까우면서 균형 인수가 +2 또는 -2가 된 조상 노드
- LL 타입: 오른쪽 회전
- LR 타입: 왼쪽 회전 -> 오른쪽 회전
- RR 타입: 왼쪽 회전
- RL 타입: 오른쪽 회전 -> 왼쪽 회전
<img src = "https://user-images.githubusercontent.com/98953721/205233994-1b526de1-aeb4-4581-8feb-2a2d1ee5541e.png" width = 800 height = 450> 


##### **LL 타입**
- 노드 X의 왼쪽 자식의 왼쪽에 노드 추가 시 발생
- 노드들을 오른쪽으로 회전
<img src = "https://user-images.githubusercontent.com/98953721/204976663-d1e52c56-c7a6-4037-8a7a-8233bd0f7b9a.png" width = 300 height = 150> 

##### **RR 타입**
- 노드 X의 오른쪽 자식의 오른쪽에 노드 추가 시 발생
- 노드들을 왼쪽으로 회전
<img src = "https://user-images.githubusercontent.com/98953721/204977418-710f65ac-e13f-4273-ab29-df7ed488bf0b.png" width = 300 height = 150> 

##### **RL 타입**
- 노드 X의 오른쪽 자식의 왼쪽에 노드가 추가 시 발생
- 오른쪽 회전 -> 왼쪽 회전  
  ⭐ 오른쪽 회전 시 J와 Y의 위치가 바뀜  
<img src = "https://user-images.githubusercontent.com/98953721/204977703-f2c03a0e-6a57-44ef-bd37-9171b9d8871b.png" width = 400 height = 150> 

##### **LR 타입**
- 노드 X의 왼쪽 자식의 오른쪽에 노드 추가 시 발생
- 왼쪽 회전 -> 오른쪽 회전  
  ⭐ 왼쪽 회전 시 J와 Y의 위치가 바뀜  
<img src = "https://user-images.githubusercontent.com/98953721/205234825-1a728615-c687-4f7d-ac93-5aeefc7b7d21.png" width = 400 height = 150> 

### **2-3. AVL 트리 예제**
<img src = "https://user-images.githubusercontent.com/98953721/205235543-4dba587e-14b4-4527-a9d5-2d39b20945e8.png" width = 600 height = 400>

# **[14장] 해싱**
## **1. 해싱이란?**
- 대부분의 탐색 방법들은 키 값을 비교함으로써 탐색하고자 하는 항목에 접근함
	- 빠른 검색을 하고자 노력 
### **1-1. 해싱(Hashing)**
- 키(key) 값에 대한 산술적 연산에 의해 테이블의 주소를 계산하여 주소로 바로 항목에 접근하는 방법
	- 키 비교 연산 수행x 
- **해시 테이블(Hash table)**: 키 값의 연산에 의해 직접 접근이 가능한 구조
- 사전(dictionary) 자료구조 활용  
<img src = "https://user-images.githubusercontent.com/98953721/205308422-364ead29-ebd7-44f8-9357-98c2c520eb3b.png" width = 400 height = 200>

## **2. 추상 자료형 사전**
### **2-1. 사전의 개념**
- **사전(dictionary)**: (키, 값) 쌍의 집합
	- 키(key): 사전의 단어처럼 항목과 항목을 구별시켜주는 것
	- 값(value): 단어에 대한 설명에 해당됨 	
- 맵(map)이나 테이블(table)로 불리기도 함
- 무조건 **키**에 의하여 항목에 접근할 수 있어야 함(정렬 여부와 무관)

### **2-2. 사전의 연산**
- 객체: 일련의 (key, value) 쌍의 집합
- 연산:
	- add(key, value): (key, value)를 사전에 추가
	- delete(key)
		- key에 해당되는 (key, value)를 찾아서 삭제
		- 관련된 value 반환
		- 탐색 실패 시 NULL을 반환
	- search(key)
		- key에 해당되는 value를 찾아서 반환
		- 탐색 실패 시 NULL을 반환

## **3. 해싱의 구조**
- 해싱에서는 자료를 저장하는 데 **배열**을 활용
	- 어떤 항목의 키만을 가지고 바로 항목이 들어 있는 배열의 인덱스를 결정하는 기법

### **3-1. 해시 함수(hash function)**
- 탐색 키를 입력받아 해시 주소를 생성하고, 이를 해시 테이블의 인덱스로 사용할 수 있도록 하는 함수
<img src = "https://user-images.githubusercontent.com/98953721/205313303-b0b7179d-349f-4ffd-b4e1-aab1df44ec08.png" width = 400 height = 250>

### **3-2. 해시 테이블의 구조**

**해시 테이블 ht**  
	- M개의 **버켓(bucket)** 으로 구성된 테이블
	- ht[0], ht[1], ... , ht[M-1]의 원소를 가짐
	- 하나의 버켓은 s개의 슬롯(slot)을 가질 수 있음
		- 서로 다른 두 개의 키가 해시 함수에 의해 동일한 해시 주소로 변환될 수 있기에, 여러 개의 항목을 동일한 버킷에 저장하기 위함임
		- 하나의 슬롯에 하나의 항목이 저장됨
	- 그러나 대부분의 경우 하나의 버킷은 하나의 슬롯을 가짐
	<img src = "https://user-images.githubusercontent.com/98953721/205316851-53aa824a-73fd-42eb-ae9a-e87ddb49f93f.png" width = 200 height = 300>

**충돌(collision)**  
	- 서로 다른 두 개의 탐색 키 k1과 k2에 대해 h(k1) = h(k2)인 경우  
    - 해시 테이블에서의 인덱스가 동일  
	- 충돌 발생 시 동일 버킷 내의 다른 슬롯에 항목 저장  
	- 충돌이 자주 발생하면 버킷 내부에서의 순차 탐색 시간이 길어짐 -> 탐색 성능 저하    
		=> 해시 함수 수정 or 해시 테이블 크기 조정 필요    
		
**오버플로우(overflow)**  
	- (충돌 수) > (버켓에 할당된 슬롯 수)
	- 더 이상 항목을 저장할 수 없음 -> 해결 필요

### **3-3. 이상적인 해싱**
- 학생 정보를 해싱으로 저장/탐색하는 상황
	- 학번 5자리 중 앞 2자리는 학과 번호, 뒤 3자리가 각 학과의 학생 번호
	- 같은 학과 학생들만 있다고 가정하면 뒤의 **3자리만** 사용해서 탐색 가능
	- 학번이 00023이라면 해당 학생의 인적사항은 해시 테이블 h[23]에 저장됨
	- 만약 해시 테이블이 1000개의 공간(000 ~ 999)을 가지고 있다고 하면 탐색 시간이 O(1)이 되므로 이상적  
		- 하나의 학번 당 하나의 배열 요소 할당  

### **3-4. 실제의 해싱**
- 실제로는 해시 테이블의 크기가 제한되어 있음    
	=> 하나의 키 당 해시 테이블에서 하나의 공간을 할당할 수가 없음  
- 필연적으로 충돌과 오버플로우 발생  
  => 실제의 해싱에서의 시간 복잡도는 O(1)보다는 떨어짐     

## **4. 해시 함수**
### **4-1. 좋은 해시 함수의 조건**
- 충돌이 적어야 함
- 해시 함수 값이 해시 테이블의 주소 영역 내에서 고르게(균일하게) 분포되어야 함
- 계산이 빨라야 함
<img src = "https://user-images.githubusercontent.com/98953721/205322061-08c8e834-498c-45dd-8c57-d7b8235ebbfb.png" width = 250 height = 200>

### **4-2. 제산 함수**
- 키를 해시 테이블의 크기로 나눈 **나머지**를 해시 주소로 사용하는 방법
- h(k) = k mod M	※ mod: 나머지 연산  
	- M: 해시 테이블의 크기
- 해시 테이블의 크기 M은 소수(prime number)를 선택  
	- 해시 주소를 상당히 고르게 분포시키기 위함
- 나머지 연산 수행 시 결과로 음수가 나오면 M을 더해줌  
  => 결과값이 항상 0에서 (M-1)이 되도록 함  
- 코드  
```C
int hash_function(int key) {
	int hash_index = key % M;
	if (hash_index < 0)
		hash_index += M;
	return hash_index;
}
```

## **5. 오버플로우 해결 기법**
- **충돌(collision)**: 서로 다른 키를 갖는 항목들이 같은 해시 주소를 가지는 현상(인덱스 동일)
- 충돌이 발생하고, 해시 주소에 더 이상 빈 버킷이 남아있지 않으면 오버플로우 발생
- 오버플로우 발생 시 해시 테이블에 항목을 더 이상 저장할 수 없음
- 오버플로우를 해결하는 방법이 요구됨 

### **5-1. 체이닝(Chaining)**
- 해시 테이블에서 하나의 위치(인덱스)가 여러 개의 항목을 저장할 수 있도록 해시 테이블의 구조를 변경하는 방법
- 오버플로우 문제를 **연결 리스트**로 해결
	- 각 버켓에 고정된 슬롯이 할당되어 있지 않음 
	- 각 버켓에 삽입/삭제가 용이한 연결 리스트 할당
	- 버켓 내에서는 연결 리스트를 순차 탐색

<img src = "https://user-images.githubusercontent.com/98953721/205327428-e85ae509-2660-469c-85d8-cc607f6b3fbf.png" width = 650 height = 500>

### **5-2. 개방 주소법(Open Addressing)**
- 특정 버킷에서 충볼 발생 시 비어있는 버킷을 찾는 방법
	- 조사(probing): 해시 테이블에서 비어있는 공간을 찾는 것 
- 종류

	**a. 선형 조사법(linear probing)**  
	- k번째부터 시작해 비어있는 공간이 나올 때까지 계속하여 조사하는 방법
	- 테이블의 끝에 도달하게 되면 다시 테이블의 처음부터 조사 --- 원형으로 회전
	- 만약 조사를 시작했던 곳으로 되돌아오게 되면 테이블이 가득 찬 것으로 판단
	<img src = "https://user-images.githubusercontent.com/98953721/205429348-46e7ccc6-a960-468a-a4fe-f4bac82e3f28.png" width = 600 height = 200>  
	
  - 군집화와 결합 문제 발생  
		- 군집화(clustering): 해시 테이블에서 한 번 충돌이 시작되면 그 위치에 항목들이 집중되는 현상  
		- 결합(coalescing): 집중된 항목들이 결합하는 현상  
	
  
  **b. 이차 조사법(quadratic probing)**  
	- 선형 조사법과 유사하지만, 다음 조사할 위치를 다음 식에 의해 결정함
		<image src = "https://user-images.githubusercontent.com/98953721/205431347-9654e183-8543-4f34-9b65-861d6656687d.png" width = 400 height = 30>
  
	- 조사되는 위치: h(k), h(k)+1, h(k)+2
  - 모든 위치를 조사하게 하려면 여전히 테이블 크기는 **소수**여야 함
	- 선형 조사법의 집중/결합 문제를 크게 완화시킬 수 있음
  
  **c. 이중 해싱법(double hashing/ 재해싱 - rehashing)**  
	- 오버플로우가 발생함에 따라 항목을 저장할 다음 위치 결정 시 원래 해시 함수와 다른 **별개**의 해시 함수를 이용하는 방법  
	- 항목들을 해시 테이블에 보다 균일하게 분포시킬 수 있는 효과적인 방법  
	- 키를 참조하여 더해지는 값이 결정됨  
		- 해시 함수값이 같더라도 키가 다르면 서로 다른 조사 순서  
	- 첫 번째 해시 함수: 원래의 해시 함수 => 키를 해시 테이블의 index로   
	- 두 번째 해시 함수: h'(k) = C - (k mod C) (C: 테이블의 크기인 M보다 약간 작은 소수)  
	- 충돌 발생 시 조사 위치: h(k), h(k) + h'(k), h(k) + 2 * h'(k), h(k) + 3 * h'(k), ...  
	
	<img src = "https://user-images.githubusercontent.com/98953721/205431837-6cb3bcab-c2d2-4d90-a9f5-ea4efdee74c4.png" width = 600 height = 400>
	

## **6. 해싱의 성능 분석**
- 이상적인 해싱의 시간 복잡도: O(1)
	- 충돌이 전혀 일어나지 않는다는 가정 하에서만 가능
- 해싱의 성능을 분석하기 위한 척도: 적재 밀도(loading density) 또는 적재 비율(loading factor)
	- 저장되는 항목의 개수(n)와 해시 테이블 크기(M)의 비율
	- α = (저장된 항목의 개수) / (해싱 테이블의 버킷의 개수) = n / M
	- α = 0: 해시 테이블이 비어있는 상태
	
- 탐색을 위한 비교 연산의 개수
	- 오픈 주소법 
		- 실패: (1/2) * (1 + 1/(1-α)^2)
		- 성공: (1/2) * (1 + 1/(1-α))
	<img src = "https://user-images.githubusercontent.com/98953721/205432378-69600b94-a0d8-45d8-84fd-ae1949ca0148.png" width = 400 height = 300>
	
	- 체이닝 방법
		- 실패: α
		- 성공: 1 + α / 2 
	<img src = "https://user-images.githubusercontent.com/98953721/205432400-8273ab17-492a-4156-af81-b8380bb2619e.png" width = 400 height = 300>
	
<img src = "https://user-images.githubusercontent.com/98953721/205432479-852ded08-1109-4385-b544-d37b07180ba2.png" width = 600 height = 300>
