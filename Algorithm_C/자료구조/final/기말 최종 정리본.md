# **[7장] 링크드 리스트II**
**⭐ 키워드: 이중 연결 리스트, 음악 재생 프로그램**

## **1. 이중 연결 리스트**
- 응용 프로그램에서 특정 노드의 양방향으로 자유롭게 움직일 필요가 있다면 단순 연결 리스트나 원형 연결 리스트는 부적합  
	-> 이중 연결 리스트를 고안
- 하나의 노드가 선행 노드와 후속 노드에 대한 두 개의 링크를 가지는 리스트
- 장점: 양방향으로 검색이 가능
- 단점: 많은 공간을 차지하고 코드가 복잡해짐

<img src="https://user-images.githubusercontent.com/98953721/200169252-ea3222f0-87e2-4d09-a494-298142ee37cd.png" width = "300" height = "100"/>  
- p = p->llink -> rlink = p->rlink->llink  
  
  => 앞뒤로 똑같이 이동할 수 있음  

### **1-1. 헤드 노드(Head Node)**
- 데이터를 가지고 있지 않은 특별한 노드  
	-> 단지 삽입, 삭제 코드를 간단하게 할 목적으로 만들어진 노드  
- 공백 상태에서는 헤드 노드만 존재  

### **1-2. 노드의 구조**
```C
typedef int element;

typedef struct DlistNode {	// 이중 연결 노드 타입
	element data;             // 데이터 필드
	struct DlistNode *llink;  // 왼쪽 링크 필드 => 선행 노드
	struct DlistNode *rlink;  // 오른쪽 링크 필드 => 후속 노드 
} DlistNode;
```

### **1-3. 삽입 연산**
- 새로 만들어진 노드의 링크는 아무런 정보도 가지고 있지 x  
	-> 새로 만들어진 노드의 링크를 먼저 바꾼다.  
<img src="https://user-images.githubusercontent.com/98953721/200170104-b1383b00-d49b-49e2-9272-7a5a79b0c807.png" width = "450" height = "200"/>  
  
```C
// 새로운 데이터를 선행 노드의 오른쪽에 삽입

void dinsert(DListNode *before, element data){
	DListNode *newnode = (DListNode *)malloc(sizeof(DListNode));
	/*데이터 저장*/
	strcpy(newnode->data, data); // 문자형 데이터라 strcpy() 사용함
	/*링크 생성*/
	newnode->llink = before; // 새로 만들어진 노드의 링크부터 생성
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode; // 후행 노드와 연결
	before->rlink = newnode; // 선행 노드와 연결
}
```

### **1-4. 삭제 연산**
<img src="https://user-images.githubusercontent.com/98953721/200170377-3c7046fb-9cde-4e5f-bec2-5edadcd1de0d.png" width = "450" height = "200"/>  

```C
// 노드 removed를 삭제
void ddelete(DListNode* head, DListNode* removed){
	if (removed == head) return;
	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}
```

### **1-5. 테스트 프로그램**
- 이중 연결 리스트에서는 보통 헤드 노드가 존재함 -> 헤드 포인터 필요 x
- head는 포인터 변수가 아닌 구조체 변수
- 이중 연결 리스트는 사용하기 전에 반드시 초기화를 해야 함  
	-> 헤더 노드의 링크 필드들이 자기 자신을 가리키도록

```C
#include <stdio.h>
#include <stdlib.h>

typedef int element;
typedef struct DListNode { 	// 이중 연결 노드 타입
	element data;
	struct DListNode* llink;
	struct DListNode* rlink;
} DListNode;

/*이중 연결 리스트를 초기화*/
void init(DListNode* phead){
	phead->llink = phead;
	phead->rlink = phead;
}

/*이중 연결 리스트의 노드를 출력*/
void print_dlist(DListNode* phead){
	DListNode* p;
	for (p = phead->rlink; p != phead; p = p->rlink) {
		printf("<-| |%d| |-> ", p->data);
	}
	printf("\n");
}

/*삽입 함수*/
// 새로운 데이터를 노드 before의 오른쪽에 삽입
void dinsert(DListNode* before, element data){
	DListNode* newnode = (DListNode*)malloc(sizeof(DListNode));
	strcpy(newnode->data, data);
	newnode->llink = before;
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode;
	before->rlink = newnode;
}

/*삭제 함수*/
void ddelete(DListNode* head, DListNode* removed){
	if (removed == head) return;
	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}

/*테스트 프로그램*/
int main(void){
	DListNode* head = (DListNode*)malloc(sizeof(DListNode));
	init(head); // 초기화

	printf("추가 단계\n");
	for (int i = 0; i < 5; i++) {
		// 헤드 노드의 오른쪽에 삽입
		dinsert(head, i);
		print_dlist(head);
	}

	printf("\n삭제 단계\n");
	for (int i = 0; i < 5; i++) {
		print_dlist(head);
		ddelete(head, head->rlink);
	}

	free(head);
	return 0;
}
```

# **2. 예제: mp3 재생 프로그램 만들기**

```C
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef char element[100];

/*이중 연결 리스트 구조체 정의*/
typedef struct DlistNode {
	element data;
	struct DlistNode* llink;
	struct DlistNode* rlink;
}DlistNode;

DlistNode* current; // 현재 재생 중인 음악

/*초기화*/
void init(DlistNode* phead) {
	phead->llink = phead;
	phead->rlink = phead;
}

/*출력*/
void print_dlist(DlistNode* phead) {
	DlistNode* p;
	for (p = phead->rlink; p != phead; p = p->rlink) {
		if (p == current)
			printf("<-| #%s# |-> ", p->data);
		else
			printf("<-| %s |-> ", p->data);
	}
	printf("\n");
}

/*삽입*/
void dinsert(DlistNode* before, element data) {
  // 새로운 노드 정의
	DlistNode* newnode = (DlistNode*)malloc(sizeof(DlistNode));
	strcpy(newnode->data, data);
  
	// 링크 생성
	newnode->llink = before;
	newnode->rlink = before->rlink;
	before->rlink->llink = newnode;
	before->rlink = newnode;
}

/*삭제*/
void ddelete(DlistNode* head, DlistNode* removed) {
	if (removed == head) return; // head 노드 삭제 시 링크를 갱신할 필요가 없음

	removed->llink->rlink = removed->rlink;
	removed->rlink->llink = removed->llink;
	free(removed);
}

/*테스트 프로그램*/
int main(void) {
	char ch;
	DlistNode* head = (DlistNode*)malloc(sizeof(DlistNode));
	init(head);

	dinsert(head, "Mamamia");
	dinsert(head, "Dancing Queen");
	dinsert(head, "Fernado");

	current = head->rlink; // 현재 재생중인 음악
	print_dlist(head);

	do {
		printf("\n명령어를 입력하시오(<, >, q): ");
		ch = getchar();
		if (ch == '<') {  // 이전 곡 재생
			current = current->llink;
			if (current == head)
				current = current->llink;
		}
		else if (ch == ">") {  // 다음 곡 
			current = current->rlink;
			if (current == head)
				current = current->rlink;
		}
		print_dlist(head);
		getchar();
	} while (ch != 'q'); // 종료 조건
}
```

### **알고리즘**  
**[dinsert() 원리]**  
<img src = "https://user-images.githubusercontent.com/98953721/206115882-5c49f776-e9c3-4e26-9fde-3740aa2d1468.png" width = 350 height = 150>  

### **실행 결과**
```
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| #Dancing Queen# |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| Dancing Queen |-> <-| #Mamamia# |->

명령어를 입력하시오(<, >, q): >
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): <
<-| Fernando |-> <-| Dancing Queen |-> <-| #Mamamia# |->

명령어를 입력하시오(<, >, q): >
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): >
<-| Fernando |-> <-| #Dancing Queen# |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): <
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->

명령어를 입력하시오(<, >, q): q
<-| #Fernando# |-> <-| Dancing Queen |-> <-| Mamamia |->
```
